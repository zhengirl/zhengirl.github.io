<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰棍工作室</title>
  
  <subtitle>python | STM32 | 树莓派 |51</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://izhen.tech/"/>
  <updated>2019-10-17T02:11:09.760Z</updated>
  <id>http://izhen.tech/</id>
  
  <author>
    <name>zhen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树莓派4B编译安装OpenCV4</title>
    <link href="http://izhen.tech/2019/10/13/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91opencv4/"/>
    <id>http://izhen.tech/2019/10/13/树莓派4B安装编译opencv4/</id>
    <published>2019-10-13T06:18:15.000Z</published>
    <updated>2019-10-17T02:11:09.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树莓派4B编译安装OpenCV4"><a href="#树莓派4B编译安装OpenCV4" class="headerlink" title="树莓派4B编译安装OpenCV4"></a>树莓派4B编译安装OpenCV4</h2><h3 id="一、找到官方的安装教程"><a href="#一、找到官方的安装教程" class="headerlink" title="一、找到官方的安装教程"></a>一、找到官方的安装教程</h3><p>​    这个教程是谷歌出来的，树莓派4B是官方推出的最新版，在树莓派3B上面的安装成功的教程不适用于树莓派4B，会遇到各种难以解决的报错问题，所以找一个好教程非常重要。教程地址：<a href="https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html。不科学上网也是可以打开的，这里我就不翻译了。推荐把SD卡的内存升级一下，16G的内存卡就会很勉强，需要删除一些不经常使用的软件，为了避免因内存不足出现的错误，建议直接将内存卡升级到32G或64G。" target="_blank" rel="noopener">https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html。不科学上网也是可以打开的，这里我就不翻译了。推荐把SD卡的内存升级一下，16G的内存卡就会很勉强，需要删除一些不经常使用的软件，为了避免因内存不足出现的错误，建议直接将内存卡升级到32G或64G。</a></p><a id="more"></a><p>​    在安装OpenCV的依赖过程中，我有两个依赖安装失败了，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgtk2.0-dev libcanberra-gtk*</span><br><span class="line">sudo apt-get install gcc-arm*</span><br></pre></td></tr></table></figure><p>​    搜了一下也没有找出合适的解决方案，就没有管这个了，但是似乎不影响后面的编译。</p><h3 id="二、判断是否安装成功"><a href="#二、判断是否安装成功" class="headerlink" title="二、判断是否安装成功"></a>二、判断是否安装成功</h3><p>在命令行中输入<code>python3</code>，然后输入<code>import cv2</code>，如果没有报错就说明成功安装，输入<code>cv2.__version__</code>查看cv2的安装版本，成功退出即可。python3是非常容易调用OpenCV的，但是如果想要用C++来调用，相对而言就复杂多了。</p><h3 id="三、读取照片并显示"><a href="#三、读取照片并显示" class="headerlink" title="三、读取照片并显示"></a>三、读取照片并显示</h3><p>​    OpenCV3和OpenCV4版本不兼容，所以如果你直接把OpenCV3运行在OpenCV4上是会报错的。我就吃了这个亏，刚开始也不是特别熟悉OpenCV，所以走一些弯路是难免的。编译C++文件有两种方式，cmake和g++，这里推荐使用cmake，更稳定。在移植代码的时候不容易出错。</p><p>参考网址：<a href="https://www.aiuai.cn/aifarm792.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm792.html</a></p><p>新建<code>opencv_test.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Need to load an image ..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat image;</span><br><span class="line">    image = imread( argv[<span class="number">1</span>], <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( image.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"No image data!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    namedWindow(<span class="string">"Display Image"</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    imshow(<span class="string">"Display Image"</span>, image);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建<code>CMakeLists.txt</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opencv4 需要 c++ 11 支持</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span>)  </span><br><span class="line">cmake_minimum_required(VERSION <span class="number">2.8</span>)</span><br><span class="line">  <span class="comment">// 工程名</span></span><br><span class="line">project( DisplayImage )</span><br><span class="line"><span class="comment">// 下面的DIR为opencv4的安装位置</span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR /usr/local/lib/cmake/opencv4)</span><br><span class="line">find_package(OpenCV REQUIRED )</span><br><span class="line">  <span class="comment">// 这一排代表要编译的文件</span></span><br><span class="line">add_executable( opencv_test opencv_test.cpp )</span><br><span class="line">target_link_libraries( opencv_test $&#123;OpenCV_LIBS&#125; )</span><br></pre></td></tr></table></figure><p>当前路径下存放待显示的图片<code>test.jpg</code>，cmake文件中需要更改自己的OpenCV4的安装目录。执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake . </span><br><span class="line">make</span><br><span class="line">./opencv_test test.jpg</span><br></pre></td></tr></table></figure><p>显示图片。</p><h3 id="四、读取摄像头数据并显示"><a href="#四、读取摄像头数据并显示" class="headerlink" title="四、读取摄像头数据并显示"></a>四、读取摄像头数据并显示</h3><p>打开摄像头并显示成功。同样是采用cmake的方式编译，套路和上面一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取视频或摄像头</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">Mat frame;</span><br><span class="line">capture &gt;&gt; frame;</span><br><span class="line">imshow(<span class="string">"读取视频"</span>, frame);</span><br><span class="line">waitKey(<span class="number">30</span>);<span class="comment">//延时30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ol><li>找个靠谱的安装opencv的教程比什么都重要，这里再次点赞这个博客。教程地址<a href="https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html，但是里面有两个依赖安装失败，尾部含有`*`号，`libcanberra-gtk*`和`gcc-arm*`，但是似乎不影响后面的编译运行。" target="_blank" rel="noopener">https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html，但是里面有两个依赖安装失败，尾部含有`*`号，`libcanberra-gtk*`和`gcc-arm*`，但是似乎不影响后面的编译运行。</a></li><li>经过了一夜的编译，第二天上午一看，编译成功了。</li><li>前一天在树莓派3B上成功运行了opencv3的程序，采用g++ 方式编译运行，在树莓派4B上希望用同样的代码跑通，但是各种报错。主要原因有两个：opencv最好用cmake的方式编译，用g++本来就是很不稳妥的；其次，opencv3和opencv4的版本兼容问题。知乎上一篇文章，<a href="https://zhuanlan.zhihu.com/p/54845295" target="_blank" rel="noopener">opencv4从入门到放弃</a>，本来被opencv2的库找不到苦恼了一上午，以为是救星，这篇文章说先试着运行samples里面的例子，但是我cmake编译时报错，现在想想可能是OpenCV4的安装路径没有匹配。首先是cpp代码中OpenCV4的版本问题，其次<code>CMakeLists</code>中第一行的代码出错；于是我就开始谷歌找错的过程，希望能够解决。均无果。愈加烦躁。各种努力，仍旧报错。</li><li>于是只好放弃官方示例中的程序，自己去找了一篇通过opencv显示图片的代码，自己修改CMakeLists的内容，于是竟然跑通了。注意：ssh中执行这个代码是无法成功的，可以编译通过，但是必须最终用树莓派自身执行。</li><li>继续尝试寻找显示摄像头的的代码，前面的铺垫工作做好，把CMakeLists略微修改一下即可。</li><li>花了将近一天加一个晚上终于调试通过。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树莓派4B编译安装OpenCV4&quot;&gt;&lt;a href=&quot;#树莓派4B编译安装OpenCV4&quot; class=&quot;headerlink&quot; title=&quot;树莓派4B编译安装OpenCV4&quot;&gt;&lt;/a&gt;树莓派4B编译安装OpenCV4&lt;/h2&gt;&lt;h3 id=&quot;一、找到官方的安装教程&quot;&gt;&lt;a href=&quot;#一、找到官方的安装教程&quot; class=&quot;headerlink&quot; title=&quot;一、找到官方的安装教程&quot;&gt;&lt;/a&gt;一、找到官方的安装教程&lt;/h3&gt;&lt;p&gt;​    这个教程是谷歌出来的，树莓派4B是官方推出的最新版，在树莓派3B上面的安装成功的教程不适用于树莓派4B，会遇到各种难以解决的报错问题，所以找一个好教程非常重要。教程地址：&lt;a href=&quot;https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html。不科学上网也是可以打开的，这里我就不翻译了。推荐把SD卡的内存升级一下，16G的内存卡就会很勉强，需要删除一些不经常使用的软件，为了避免因内存不足出现的错误，建议直接将内存卡升级到32G或64G。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://qengineering.eu/install-opencv-4.1-on-raspberry-pi-4.html。不科学上网也是可以打开的，这里我就不翻译了。推荐把SD卡的内存升级一下，16G的内存卡就会很勉强，需要删除一些不经常使用的软件，为了避免因内存不足出现的错误，建议直接将内存卡升级到32G或64G。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="树莓派" scheme="http://izhen.tech/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派4B" scheme="http://izhen.tech/tags/%E6%A0%91%E8%8E%93%E6%B4%BE4B/"/>
    
      <category term="OpenCV4" scheme="http://izhen.tech/tags/OpenCV4/"/>
    
      <category term="环境搭建" scheme="http://izhen.tech/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL底层结构</title>
    <link href="http://izhen.tech/2019/10/08/01%20SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://izhen.tech/2019/10/08/01 SQL查询语句是如何执行的/</id>
    <published>2019-10-08T12:57:42.000Z</published>
    <updated>2019-10-10T02:33:43.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL底层结构"><a href="#MySQL底层结构" class="headerlink" title="MySQL底层结构"></a>MySQL底层结构</h2><p>从MySQL的基础架构学起，比如，有一个非常简单的表T，表T只有一个ID字段，执行下面的查询语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br></pre></td></tr></table></figure><p>这条查询语句在MySQL内部是如何执行的呢？</p><a id="more"></a><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器和视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构是插件式的，支持InnoDB，MyISAM，Memory等多个存储引擎。不同的存储引擎共用一个Server层，即从存储器到执行器的部分。</p><h3 id="一、连接器"><a href="#一、连接器" class="headerlink" title="一、连接器"></a>一、连接器</h3><p>第一步，先连接到这个数据库，这时候站在第一位的是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令之后，需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致密码泄露。如果你连接的是生产服务器，强烈建议你不要这样做。</p><p>连接命令中的mysql是客户端工具，用来跟服务器建立连接。在完成经典的TCP握手后，连接器就开始认证身份，这时候用的是输入的是用户名和密码。</p><ul><li>如果用户名或密码不对，就会收到一个“Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器就会到权限表中查看拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响到已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间默认是wait_timeout控制的，默认值是8小时。如果在连接被断开后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立的连接的过程通常是比较复杂的，因此建议在使用中尽量减少建立连接的动作，即尽量使用长连接。</p><p>但是全部使用长连接后，可能会出现MySQL占用内存涨的特别快的情况，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放，所以如果长连接累计下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现象上看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？有两种解决方案：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connect来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="二、查询缓存"><a href="#二、查询缓存" class="headerlink" title="二、查询缓存"></a>二、查询缓存</h3><p>连接建立完成后，就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句则其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>但是大多数情况下建议不要使用查询缓存？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>同时，MySQL 8.0版本将查询缓存整块删掉了，即8.0后彻底没有这个功能了。</p><h3 id="三、分析器"><a href="#三、分析器" class="headerlink" title="三、分析器"></a>三、分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先做“词法分析”，识别字符串是什么，代表什么；然后做“语法分析”，语法分析器根据语法规则，判断SQL语句是否满足MySQL语法。</p><p>一般语法错误会提示第一个出现错误的位置，因此要关注的是后面的内容。</p><h3 id="四、优化器"><a href="#四、优化器" class="headerlink" title="四、优化器"></a>四、优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。</p><h3 id="五、执行器"><a href="#五、执行器" class="headerlink" title="五、执行器"></a>五、执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，然后进入执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL底层结构&quot;&gt;&lt;a href=&quot;#MySQL底层结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL底层结构&quot;&gt;&lt;/a&gt;MySQL底层结构&lt;/h2&gt;&lt;p&gt;从MySQL的基础架构学起，比如，有一个非常简单的表T，表T只有一个ID字段，执行下面的查询语句：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select * from T where ID=10;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这条查询语句在MySQL内部是如何执行的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://izhen.tech/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://izhen.tech/tags/MySQL/"/>
    
      <category term="底层" scheme="http://izhen.tech/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析</title>
    <link href="http://izhen.tech/2019/09/12/DNS%E6%9F%A5%E8%AF%A2/"/>
    <id>http://izhen.tech/2019/09/12/DNS查询/</id>
    <published>2019-09-12T01:52:31.000Z</published>
    <updated>2019-09-13T02:20:19.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS概述"><a href="#DNS概述" class="headerlink" title="DNS概述"></a>DNS概述</h2><h3 id="域名系统：互联网上主机-路由器的识别问题："><a href="#域名系统：互联网上主机-路由器的识别问题：" class="headerlink" title="域名系统：互联网上主机/路由器的识别问题："></a>域名系统：互联网上主机/路由器的识别问题：</h3><ol><li>IP地址</li><li>域名： <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li><li>多层命名服务器构成的分布式数据库</li></ol><p><strong>DNS服务：</strong></p><ol><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：Web服务器<a id="more"></a><h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3></li></ol><p>当一个用户在浏览器中输入<code>www.baidu.com</code>时，DNS解析主要有以下几个步骤：</p><ol><li><p>浏览器检查缓存中有没有这个域名对应的解析过的IP，如果缓存命中，解析结束；未命中，进入下个阶段。（浏览器的缓存大小和缓存时间都是有限制的）</p></li><li><p>查找操作系统缓存中是否有这个域名对应的DNS解析结果。缓存命中，解析结束。未命中，进入下个阶段（在Windows中可以通过<code>C:Windows\System32\drivers\etc\hosts</code>查看）;</p></li><li><p>如果本地缓存无法完成，那么就会把这个域名发送到LDNS（本地域名服务器），如果在学校接入互联网，那么LNDS就在学校；如果在小区接入互联网，那么这个LDNS就是接入互联网的应用提供商，即电信或联通。</p><p>这个域名服务器的性能很好，缓存时间受域名的失效时间限制，不受缓存空间的限制。大约80%的域名解析都到这里就完成了。故LDNS承担了主要的域名解析工作;</p></li><li><p>如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析；</p></li><li><p>根域名服务器返回给本地域名服务器一个所查询的顶级域名服务器。顶级域名服务器包括<code>.com, .cn, .org</code>等。全球有十三台根域名服务器。</p></li><li><p>本地域名服务器再向上一步返回的顶级域名服务器发送请求；</p></li><li><p>接受请求的顶级域名服务器查找并返回此域名对应的权威域名服务器的地址。</p></li><li><p>权威域名服务服务器会查询存储的域名和IP的映射关系表，在正常情况下根据域名得到IP地址，连同一个TTL值返回给LDNS域名服务器。</p></li><li><p>LDNS缓存这个域名和IP，缓存的时间由TTL控制。</p></li><li><p>把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析结束。</p></li></ol><h4 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h4><p>本地域名服务器也能够缓存顶级域名服务器的地址，因而允许本地DNS绕过查询链中的根域名服务器。</p><p>主机向LDNS查询是递归查询，LDNS向根域名服务器查询是迭代查询。</p><p><strong>互联网的域名结构：</strong></p><p><img src="https://img.moilk.top/img/zhen/2019-09-12-134443.png" alt="image-20190912214442698"></p><h3 id="DNS缓存："><a href="#DNS缓存：" class="headerlink" title="DNS缓存："></a>DNS缓存：</h3><p>只要域名解析服务器获得域名-IP映射，即缓存这一映射。一段时间过后，缓存条目失效。<strong>本地域名服务器一般会缓存顶级域名服务器的映射，因此根域名服务器不经常别访问</strong>。有效时间（两天）</p><p>DNS可以使用UDP或者TCP进行传输，使用的<strong>端口号都为53</strong>.大多数情况下DNS使用UDP进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用TCP进行传输：</p><ul><li>返回的响应超过512字节（UDP）最大支持512字节；</li><li>区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）</li></ul><h3 id="DNS记录和消息格式"><a href="#DNS记录和消息格式" class="headerlink" title="DNS记录和消息格式"></a>DNS记录和消息格式</h3><p>实现DNS分布式服务器的所有DNS服务器共同存储了资源记录，RR提供了主机名到IP地址的映射。</p><p>资源记录（RR）包含了四个字段：<code>name，value，type，ttl</code></p><p>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value的值取决于Type：</p><ul><li>如果Type=A，则Name是主机域名，Value是该主机域名对应的IP地址。例如(relay.bar.foo.com, 145.37.93.126, A)就是一条类型A的记录。</li><li>如果Type=NS，则Name是个域（如foo.com），而Value是知道如何获得该域中主机地址的权威DNS服务器的主机域名。简单来说就是由哪个DNS服务器对该域名进行解析，如（foo.com, dns.foo.com, NS)是一条类型NS的记录。</li><li>如果Type=CNAME，Name是某一真实域名的别名，Value是真实域名。简称别名解析，例如(foo.com, relay.bar.foo.com, CNAME)就是一条CNAME类型的记录。</li><li>如果Type=MX，Value是与name相对应的邮件服务器的域名。（foo.com, mail.bar.foo.com, MX）就是一条MX记录。</li></ul><p>概要如下表所示：</p><table><thead><tr><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>A</td><td>将域名指向一个 IPv4 地址</td></tr><tr><td>NS</td><td>将子域名指向其它 DNS 服务器解析</td></tr><tr><td>CNAME</td><td>将域名指向另一个域名</td></tr><tr><td>MX</td><td>将域名指向邮件服务器地址</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DNS概述&quot;&gt;&lt;a href=&quot;#DNS概述&quot; class=&quot;headerlink&quot; title=&quot;DNS概述&quot;&gt;&lt;/a&gt;DNS概述&lt;/h2&gt;&lt;h3 id=&quot;域名系统：互联网上主机-路由器的识别问题：&quot;&gt;&lt;a href=&quot;#域名系统：互联网上主机-路由器的识别问题：&quot; class=&quot;headerlink&quot; title=&quot;域名系统：互联网上主机/路由器的识别问题：&quot;&gt;&lt;/a&gt;域名系统：互联网上主机/路由器的识别问题：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;IP地址&lt;/li&gt;
&lt;li&gt;域名： &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;多层命名服务器构成的分布式数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;DNS服务：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;域名向IP地址的翻译&lt;/li&gt;
&lt;li&gt;主机别名&lt;/li&gt;
&lt;li&gt;邮件服务器别名&lt;/li&gt;
&lt;li&gt;负载均衡：Web服务器&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://izhen.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DNS解析" scheme="http://izhen.tech/tags/DNS%E8%A7%A3%E6%9E%90/"/>
    
      <category term="DNS缓存" scheme="http://izhen.tech/tags/DNS%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信的各种方式及比较</title>
    <link href="http://izhen.tech/2019/09/02/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BB%86%E8%8A%82/"/>
    <id>http://izhen.tech/2019/09/02/进程通信的方式和细节/</id>
    <published>2019-09-02T03:54:07.000Z</published>
    <updated>2019-09-13T07:58:22.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间通信的各种方式"><a href="#进程间通信的各种方式" class="headerlink" title="进程间通信的各种方式"></a>进程间通信的各种方式</h2><p>进程间通信的方法包括管道(PIPE)、消息队列、信号、共享内存以及套接字(Socket)。</p><h3 id="一、管道"><a href="#一、管道" class="headerlink" title="一、管道"></a>一、管道</h3><p>管道通常指无名管道，是UNIX系统IPC最古老的形式。</p><p>特点：</p><ol><li>半双工（数据只能单向流动），具有固定的读端和写端</li><li>只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</li><li>也可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write函数，但它不是普通的文件。</li></ol><a id="more"></a><p>单个进程的管道几乎没有任何用处。所以，通常调用pipe的进程接着调用fork，这样就创建了父进程与子进程之间的IPC通道。</p><p><img src="https://img.moilk.top/img/zhen/2019-09-02-035443.png" alt="image-20190902113226353"></p><p>如果数据从父进程流向子进程，则关闭父进程的读端(fd[0])与子进程的写端(fd[1]);反之，可以使数据流从子进程流向父进程。</p><h3 id="二、FIFO-命名管道"><a href="#二、FIFO-命名管道" class="headerlink" title="二、FIFO 命名管道"></a>二、FIFO 命名管道</h3><p>FIFO，也称为命名管道，是一种文件类型。</p><p>特点：</p><ol><li>FIFO可以在无关的进程之间交换数据，与无名管道不同</li><li>FIFO有路径名与之关联，以一种特殊设备文件形式存在于文件系统中。</li></ol><p>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO同时清除数据，并且“先进先出”。</p><p><img src="https://img.moilk.top/img/zhen/2019-09-02-035444.png" alt="image-20190902113557256"></p><h3 id="三、消息队列"><a href="#三、消息队列" class="headerlink" title="三、消息队列"></a>三、消息队列</h3><p>消息队列，是消息的链接表，存放在内核中。一个消息队列有一个标志符（即队列ID）来标识。</p><p>特点：</p><ol><li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级</li><li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li><li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</li></ol><h3 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h3><p>信号量是一个计数器，信号量用于实现进程间的同步与互斥，而不是存储进程间通信数据。</p><p>信号量可以用来控制多个进程对共享资源的访问。若此信号量的值为正，则进程可以使用该资源；进程将信号量减一，表示其使用了一个资源单元。若此信号量的值为0，则进程进入休眠状态，直至信号量位于0.若一个进程不再使用由一个信号量控制的共享资源时，该信号值增1.如果有进程正在休眠等待此信号量，则唤醒它们。</p><p>特点：</p><ol><li>信号量用于进程间资源的同步，若要在进程间传递数据需要结合共享内存。</li><li>信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。</li><li>支持信号量组。</li></ol><h3 id="五、共享内存"><a href="#五、共享内存" class="headerlink" title="五、共享内存"></a>五、共享内存</h3><p>共享内存，指两个或多个进程共享一个给定的存储区。</p><p>特点：</p><ol><li>共享内存是最快的一种IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以需要同步</li><li>信号量+共享内存通常会结合在一起使用，使用信号量用来同步对同享内存的访问。</li></ol><h3 id="六、套接字"><a href="#六、套接字" class="headerlink" title="六、套接字"></a>六、套接字</h3><p>套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器的进程通信。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程间通信的各种方式&quot;&gt;&lt;a href=&quot;#进程间通信的各种方式&quot; class=&quot;headerlink&quot; title=&quot;进程间通信的各种方式&quot;&gt;&lt;/a&gt;进程间通信的各种方式&lt;/h2&gt;&lt;p&gt;进程间通信的方法包括管道(PIPE)、消息队列、信号、共享内存以及套接字(Socket)。&lt;/p&gt;
&lt;h3 id=&quot;一、管道&quot;&gt;&lt;a href=&quot;#一、管道&quot; class=&quot;headerlink&quot; title=&quot;一、管道&quot;&gt;&lt;/a&gt;一、管道&lt;/h3&gt;&lt;p&gt;管道通常指无名管道，是UNIX系统IPC最古老的形式。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;半双工（数据只能单向流动），具有固定的读端和写端&lt;/li&gt;
&lt;li&gt;只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系&lt;/li&gt;
&lt;li&gt;也可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write函数，但它不是普通的文件。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://izhen.tech/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程同步" scheme="http://izhen.tech/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>HTTP保持登录状态的机制</title>
    <link href="http://izhen.tech/2019/08/30/HTTP%E4%BF%9D%E6%8C%81%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/"/>
    <id>http://izhen.tech/2019/08/30/HTTP保持登录状态/</id>
    <published>2019-08-30T08:11:36.000Z</published>
    <updated>2019-09-12T14:10:33.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP保持登录状态"><a href="#HTTP保持登录状态" class="headerlink" title="HTTP保持登录状态"></a>HTTP保持登录状态</h2><h3 id="1-无状态的HTTP协议"><a href="#1-无状态的HTTP协议" class="headerlink" title="1. 无状态的HTTP协议"></a>1. 无状态的HTTP协议</h3><p>HTTP无状态是指：HTTP协议对事物处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成整个过程。这个过程是独立的的，<strong>服务器不会记录前后状态的变化</strong>，也就是缺失状态记录。这就是说如果后续处理需要前面的信息，就必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然太浪费资源了。<br><a id="more"></a><br>于是两种用于保持HTTP连接状态的技术就出现了，即Session和Cookies。Session在服务端，也就是网站的服务器，用来<strong>保存用户的会话信息</strong>；Cookie在客户端，有了Cookies，浏览器在下次访问网站是会自动附带上它发送给服务器，服务器通过识别Cookies鉴别出是哪个用户，<strong>判断是否是登录状态</strong>，然后返回对应的响应。</p><p>Cookies保存了登录的凭证，有了它，只需要在下次请求中携带Cookies发送请求就不用重新输入用户名，密码等信息重新登录了。所以在爬虫中，一般会将登录成功后获取的Cookies放在请求头中直接请求，而不必重新模拟登录。</p><h3 id="2-原理剖析"><a href="#2-原理剖析" class="headerlink" title="2. 原理剖析"></a>2. 原理剖析</h3><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这一过程可以称为一个Session。</p><p>而Web中，Session对象用来存储特定用户Session所需的属性和配置信息。这样，当用户在各个Web网页之间跳转时，存储在Session对象的变量不会丢失，而是在整个Session中一直存在下去。当用户请求来自应用程序的web网页时，如果该用户还没有Session，则web服务器会自动创建一个Session对象。而当Session过期或被放弃的时候，服务器就会终止该Session。</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>Cookies指某些网站为了辨别用户身份，进行Session跟踪而存储在本地终端上的数据。</p><p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有Set-Cookie的字段相应给客户端，用来标记是哪个用户，客户端会把Cookies保存起来，Cookies携带了SessionID信息，服务器检查该Cookies即可查找到对应的Session是什么，然后再判断Session来以此辨别用户状态。</p><p>成功登录某个网站时，服务器会告诉客户端设置哪些Cookies信息，在后续访问客户端会把Cookies发送给服务器，服务器再找到对应的Session加以判断。如果Session中某些设置登录状态是有效的，就证明用户处于登录状态，此次返回登录之后才可以查看网页内容，浏览器进行解析，用户就可以看到内容了。</p><h3 id="3-Cookies内容"><a href="#3-Cookies内容" class="headerlink" title="3. Cookies内容"></a>3. Cookies内容</h3><ol><li>name 该Cookies的名称，一旦创建，名称不可更改</li><li>Value 该Cookie的值，如果值是Unicode字符，需要为字符编码，如果是二进制数据，则需要BASE64编码</li><li>Domain：可以访问该Cookie的域名。如果设置为12306.com，则所有以12306.com结尾的域名都可以访问该Cookie。</li><li>Max age:该Cookie失效的时间，单位为秒, 常与Expires一起使用。Max age如果是正数，则该Cookie在Max Age秒后失效。如果为负数，则关闭浏览器时Cookie失效。浏览器也不会以任何形式保存该Cookie。</li><li>Path：该Cookie的使用路径。如果设置为/path/，则只有路径为/path/的页面可以访问该Cookie。如果设置为/，则本域名下所有页面都可以访问该Cookie。</li><li>Size：该Cookie的大小。</li><li>HTTP字段：Cookie的httponly属性。若此属性的值为true，则只用在HTTP头带有此Cookie信息，而不能通过document.cookie来访问此Cookie。</li><li>Secure:该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据前先将数据加密。默认为false。</li></ol><h3 id="4-常见误区"><a href="#4-常见误区" class="headerlink" title="4.常见误区"></a>4.常见误区</h3><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><p>传说中会话Cookie是把Cookie放在浏览器内存中，浏览器关闭后该Cookie失效，持久Cookie则会保持到客户端的硬盘中，下次还可以继续使用，长久保持用户登录状态。</p><p>传说是假的，过期时间是由Cookie的Max Age或Expire决定的。持久化Cookie是把有效时间设置的比较长，这样下次访问时仍然携带之前的cookie，就可以直接保持登录状态。</p><h4 id="Session误区"><a href="#Session误区" class="headerlink" title="Session误区"></a>Session误区</h4><p>对于Session来说，除非程序员通知服务器删除Session，否则服务器会一直保留。</p><p>但是在我们关闭浏览器后，浏览器不会主动关闭之前通知服务器它将要关闭，所以服务器不会有机会知道浏览器已经关闭。</p><p>大部分Session机制使用会话Cookis来保存SessionID信息，而关闭浏览器后，<strong>Cookies消失了，再次连接服务器时，就无法找到原来的Session了</strong>。如果服务器设置的Cookies被浏览器保存到硬盘上，或者用某种手段改写浏览器发出HTTP请求头把原来的Cookies发送给服务器，则当再次打开服务器是，仍然能够找到原来的SessionID，仍然可以保存登录状态。</p><p>由于关闭浏览器不会使Session被删除，这就需要服务器为Session设置一个失效时间，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就认为客户端停止了活动，会把Session删除以节省存储空间。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.imooc.com/article/38017" target="_blank" rel="noopener">Session和Cookies的原理及代码实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP保持登录状态&quot;&gt;&lt;a href=&quot;#HTTP保持登录状态&quot; class=&quot;headerlink&quot; title=&quot;HTTP保持登录状态&quot;&gt;&lt;/a&gt;HTTP保持登录状态&lt;/h2&gt;&lt;h3 id=&quot;1-无状态的HTTP协议&quot;&gt;&lt;a href=&quot;#1-无状态的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;1. 无状态的HTTP协议&quot;&gt;&lt;/a&gt;1. 无状态的HTTP协议&lt;/h3&gt;&lt;p&gt;HTTP无状态是指：HTTP协议对事物处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成整个过程。这个过程是独立的的，&lt;strong&gt;服务器不会记录前后状态的变化&lt;/strong&gt;，也就是缺失状态记录。这就是说如果后续处理需要前面的信息，就必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然太浪费资源了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://izhen.tech/categories/HTTP/"/>
    
    
      <category term="Session" scheme="http://izhen.tech/tags/Session/"/>
    
      <category term="Cookies" scheme="http://izhen.tech/tags/Cookies/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB中的事务隔离级别和锁的关系</title>
    <link href="http://izhen.tech/2019/08/19/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://izhen.tech/2019/08/19/事务隔离级别与锁的关系/</id>
    <published>2019-08-19T12:50:39.000Z</published>
    <updated>2019-09-13T07:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB中的事务隔离级别和锁的关系"><a href="#InnoDB中的事务隔离级别和锁的关系" class="headerlink" title="InnoDB中的事务隔离级别和锁的关系"></a>InnoDB中的事务隔离级别和锁的关系</h2><h3 id="一次封锁or两段锁"><a href="#一次封锁or两段锁" class="headerlink" title="一次封锁or两段锁"></a>一次封锁or两段锁</h3><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不使用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p><a id="more"></a><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁和解锁阶段（因此叫两段锁）：</p><ul><li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其他事务可以继续加共享锁，但不能加排它锁）,在进行写操作之前要申请并获得X锁（排他锁，其他事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li><li>解锁阶段：当事务释放了一个封锁之后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li></ul><table><thead><tr><th>事务</th><th>加锁/解锁处理</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>insert into test…</td><td>加insert对应的锁</td></tr><tr><td>update test set…</td><td>加update对应的锁</td></tr><tr><td>delete from test…</td><td>加delete对应的锁</td></tr><tr><td>commit</td><td>事务提交时，同时释放insert、update、delete对应的锁</td></tr></tbody></table><p>这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）</p><h3 id="事务中的加锁方式"><a href="#事务中的加锁方式" class="headerlink" title="事务中的加锁方式"></a>事务中的加锁方式</h3><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。</p><p><img src="https://img.moilk.top/img/zhen/2019-08-19-130620.png" alt="image-20190819210619985"></p><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p>MySQL中常见的有表锁和行锁，也有新加入的元数据锁(meta data lock MDL)等，表锁是对一整张表加锁虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。</p><p>行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其他数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理数据，这里主要讨论行锁。</p><h3 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h3><p>在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改是需要加锁的。</p><p>为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。</p><p>但是我们注意到，teacher_id是有索引的，如果是没有索引的class_name呢，那么MySQL会给整张表的所有数据行加行锁，这听起来有点不可思议，但是当SQL运行的过程中，MySQL并不知道哪些数据行是class_name=”初三一班“，如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL_Server层进行过滤。</p><p>但在实际使用过程中，MySQL做了一些改进，在MySQL_Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁（违背了二段锁的约束）,这样做，保证了最后只有持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使MySQL，为了效率也是会违反规范的。</p><p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p><h3 id="Repeatable-Read-可重读"><a href="#Repeatable-Read-可重读" class="headerlink" title="Repeatable Read(可重读)"></a>Repeatable Read(可重读)</h3><p>这是MySQL中InnoDB默认的隔离级别。我们姑且分为”读“和”写“两个模块来讲解。</p><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时，会看到相同的数据行，有点抽象。</p><h4 id="不可重复度和幻读的区别"><a href="#不可重复度和幻读的区别" class="headerlink" title="不可重复度和幻读的区别"></a>不可重复度和幻读的区别</h4><p>很多人搞不清楚不可重复读和幻读的区别，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p><p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该SQL第一次读取到数据后，就将这些数据加锁，其他事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还有可以insert数据提交，这是事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效避免幻读、不可重复读、脏读等，但会极大的降低数据库的并发能力。</p><p>所以说不可重复度和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p><p>上文说的是，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，处于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这种问题。</p><h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ol><li>悲观锁</li></ol><p>正如其名，它指的是对外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务无法修改这些数据。修改删除数据时也要加锁，其他事务无法处读取这些数据。</p><ol start="2"><li>乐观锁</li></ol><p>相对悲观锁而言，乐观锁采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据的锁机制实现，以保证操作最大程度的独占性。但随着而来就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本的记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个字段“version”来实现。读取此数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行对比，如果提交的版本号大于数据表当前版本号，则予以更新，否则认为是过期数据。</p><h3 id="MVCC在MySQL的InnoDB中的实现"><a href="#MVCC在MySQL的InnoDB中的实现" class="headerlink" title="MVCC在MySQL的InnoDB中的实现"></a>MVCC在MySQL的InnoDB中的实现</h3><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。在可重读Repeatable reads事务隔离级别下：</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新记录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来行。</li></ul><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>在数据库方面的教科书学到，PR是可重复读的，但无法解决幻读，而只有在Serializable级别才能解决幻读。经测试，在MySQL中是不存在这种情况的，在事务C提交后，事务A还是不会读到这条数据。可见在RR级别中，是解决了幻读的问题的。</p><h3 id="“读”和“读”的区别"><a href="#“读”和“读”的区别" class="headerlink" title="“读”和“读”的区别"></a>“读”和“读”的区别</h3><p>事务的隔离级别其实都是对于读数据的定义，但到了这里，就被拆成了读和写两个模块来讲解。这主要是因为MySQL中的读，和事务隔离级别中的读，是不一样的。</p><p>在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效性特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读，而读取数据库当前版本数据的方式，叫当前读。很显然，在MVCC中：</p><ul><li><p>快照读：即SELECT</p><p>SELECT * fron table…</p></li><li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><p>SELECT * from table where ？lock in share modes;</p><p>SELECT * from table where ? for update;</p><p>insert；</p><p>update；</p><p>delete;</p></li></ul><p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其他锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p><h3 id="写（“当前读”）"><a href="#写（“当前读”）" class="headerlink" title="写（“当前读”）"></a>写（“当前读”）</h3><p>事务的隔离级别虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”,实际上讲的快照读，而这里说的“写”就是当前读了。</p><p>为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。</p><h3 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h3><p>Next-key锁是行锁和GAP（间隙锁）的合并，行锁上文已经介绍了，接下来GAP间隙锁。行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。我们可以看看RR级别和RC级别的对比：</p><p>RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读，这个锁，就是GAP锁。</p><p>不仅用行锁锁住了相应的数据行，同时也在两边的区间，加入了gap锁，这样事务B就无法在这两个区间insert进新数据。</p><p>受限于这种实现方式，InnoDB很多时候会锁住不需要锁的区间。</p><p>如果使用的是没有索引的字段，那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没用索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其他事务无法插入任何数据。</p><p>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的Next-KEY锁共同解决了RR级别在写数据时的幻读问题。</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p><p>注意，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">InnoDB中的事务隔离级别与锁的关系</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;InnoDB中的事务隔离级别和锁的关系&quot;&gt;&lt;a href=&quot;#InnoDB中的事务隔离级别和锁的关系&quot; class=&quot;headerlink&quot; title=&quot;InnoDB中的事务隔离级别和锁的关系&quot;&gt;&lt;/a&gt;InnoDB中的事务隔离级别和锁的关系&lt;/h2&gt;&lt;h3 id=&quot;一次封锁or两段锁&quot;&gt;&lt;a href=&quot;#一次封锁or两段锁&quot; class=&quot;headerlink&quot; title=&quot;一次封锁or两段锁&quot;&gt;&lt;/a&gt;一次封锁or两段锁&lt;/h3&gt;&lt;p&gt;因为有大量的并发访问，为了预防死锁，一般应用中推荐一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不使用，因为在事务开始阶段，数据库并不知道会用到哪些数据。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://izhen.tech/categories/MySQL/"/>
    
    
      <category term="事务隔离" scheme="http://izhen.tech/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    
      <category term="锁" scheme="http://izhen.tech/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS的建立过程</title>
    <link href="http://izhen.tech/2019/08/14/HTTPS/"/>
    <id>http://izhen.tech/2019/08/14/HTTPS/</id>
    <published>2019-08-14T14:09:41.000Z</published>
    <updated>2019-09-13T08:23:05.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><p>HTTP有如下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li><li>无法验证报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS不是新协议，而是让HTTP先和SSL（Secure Socket Layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。</p><a id="more"></a><p>通过使用SSL，HTTPS具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p><p>HTTPS采用混合的加密机制，使用非对称秘钥加密用于传输对称秘钥来保证传输过程的安全性，之后使用对称秘钥加密进行通信来保证通信过程的效率。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>除了加/解密之外，还可以用加密系统对报文进行签名，以说明是谁编写的报文，同时证明报文未被篡改过。这种技术称为数字签名。</p><p>使用数字签名有以下两个好处：</p><ul><li>签名可以证明是作者编写了这条报文。只有作者才会有最机密的私有秘钥。因此，只有作者才能计算出这些校验和。校验和就像来自作者的个人”签名“一样。</li><li>签名可以防止报文被篡改。如果有恶意攻击者在报文传输过程中对其进行了修改，校验和就不再匹配了。由于校验和只有作者保密的私有秘钥才能产生。所以攻击者无法为篡改了的报文伪造出正确的校验码。</li></ul><p>下面的例子说明了A是如何向节点B发送一条报文，并对其进行签名的。</p><ul><li>节点A将变长报文用哈希函数提取出定长的摘要</li><li>节点A对摘要应用了一个“签名”函数，这个函数以用户的私有秘钥作为参数，因为只有用户才知道私有秘钥，所以正确的签名函数会说明签名者就是其所有者。</li><li>一旦计算出签名，节点A就将其附加在报文的末尾，并将报文和签名都发送给B。</li><li>在接收端，如果节点B需要确定报文确实是节点A发出的，而且没有被篡改过，节点B就可以对签名进行检查。节点B接收经私有秘钥加密的签名，使用公钥解密，得到拆包后的摘要。由此证明，报文的确是由A发出的。B再对信件使用哈希函数，将得到的结果与节点B解密的摘要版本作对比，如果匹配，说明这封信未修改过。</li></ul><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>公钥存在伪装的问题，通过使用数字证书来对公钥进行认证。</p><p>数字证书认证机构（CA）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向CA提出公开秘钥的申请，CA在判明申请者的身份之后，会对已申请的公开密钥做数字签名，具体过程如下：CA用自己的私钥对服务器申请的公钥已以及相关信息加密，生成数字证书，然后将这个公开秘钥和数字签名发送给服务器。进行HTTPS通信时就多了一个步骤：</p><ol><li>服务器发送请求时，在签名的同时，附上自己的数字证书；</li><li>客户端收到请求后，用CA的公钥解开数字证书，得到其中服务器的公开秘钥；</li><li>客户端用得到的公钥对数字签名进行验证，如果验证通过了，就可以开始通信了。</li></ol><h3 id="HTTPS的通信过程"><a href="#HTTPS的通信过程" class="headerlink" title="HTTPS的通信过程"></a>HTTPS的通信过程</h3><p><img src="https://img.moilk.top/img/zhen/2019-08-31-085823.png" alt="image-20190831165820155"></p><p>由上图可知，HTTPS的通信过程主要分为以下几个步骤：</p><ul><li>客户端向服务端发送请求；</li><li>服务端用将本身的数字证书发送给客户端；</li><li>客户端用自己的CA（主流的CA机构证书一般都内置在各个主流浏览器中)公钥去解密证书，如果证书有问题会提示风险</li><li>如果证书没问题，客户端会生成一个对称加密的随机秘钥然后再用刚刚解密的服务器端公钥对数据进行加密，然后发送给服务器</li><li>服务器收到以后用自己的私钥对客户端发来的对称秘钥进行解密</li><li>之后双方就拿着这个对称加密秘钥来进行正常的通信</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTPS简介&quot;&gt;&lt;a href=&quot;#HTTPS简介&quot; class=&quot;headerlink&quot; title=&quot;HTTPS简介&quot;&gt;&lt;/a&gt;HTTPS简介&lt;/h2&gt;&lt;p&gt;HTTP有如下安全性问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用明文进行通信，内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，通信方的身份有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法验证报文的完整性，报文有可能遭篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTPS不是新协议，而是让HTTP先和SSL（Secure Socket Layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://izhen.tech/categories/HTTP/"/>
    
    
      <category term="HTTPS" scheme="http://izhen.tech/tags/HTTPS/"/>
    
      <category term="加密" scheme="http://izhen.tech/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和ConcurrentHashMap</title>
    <link href="http://izhen.tech/2019/08/13/HashMap%E5%92%8CConCurrentHashMap/"/>
    <id>http://izhen.tech/2019/08/13/HashMap和ConCurrentHashMap/</id>
    <published>2019-08-13T07:22:13.000Z</published>
    <updated>2019-09-13T08:45:54.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><blockquote><p>Map这样的<code>Key Value</code>在软件开发中是非常经典的结构，常用于在内存中存放数据。</p></blockquote><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>众所周知HashMap底层是基于<code>数组+链表</code>组成的，不过jdk1.7和1.8中实现稍有不同，为了便于理解，以下源码分析以JDK1.7为主</p><a id="more"></a><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>内部包含了一个Entry类型的数组table。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>Entry存储着键值对。它包含了四个字段，从next字段我们可以看出来Entry是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用<strong>拉链法</strong>来解决冲突，同一个链表存放哈希值和散列桶取模运算结果相同的Entry。</p><p><img src="https://img.moilk.top/img/zhen/2019-08-13-073728.png" alt="image-20190813153728141"></p><p>下面是1.7中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Entry&lt;K, V&gt; next;</span><br><span class="line">  <span class="keyword">int</span> hash;</span><br><span class="line">  </span><br><span class="line">  Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n)&#123;</span><br><span class="line">    value = v;</span><br><span class="line">    key = k;</span><br><span class="line">    next = n;</span><br><span class="line">    hash = h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map.Entry e = (Map.Entry)o;</span><br><span class="line">    Object k1 = getKey();</span><br><span class="line">    Object k2 = e.getKey();</span><br><span class="line">    <span class="keyword">if</span>(k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2)))&#123;</span><br><span class="line">      Object v1 = getValue();</span><br><span class="line">      Object v2 = e.getValue();</span><br><span class="line">      <span class="keyword">if</span>(v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Object.hashCode(getKey()) ^ Object.hashCode(getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拉链法的工作原理"><a href="#拉链法的工作原理" class="headerlink" title="拉链法的工作原理"></a>拉链法的工作原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure><ol><li>新建一个HashMap，默认大小为16；</li><li>插入&lt;K1, V1&gt;键值对，先计算K1的hashCode为115，使用除留余数法得到所在的桶下标115%16=3</li><li>插入&lt;K2, V2&gt;键值对，先计算K2的hashCode为118，使用除留余数法达到所在的桶下标118%16=6；</li><li>插入&lt;K3, V3&gt;键值对，计算K3的hashCode为118，使用除留余数法得到所在的桶下标118%16=6，插在&lt;K2,V2&gt;前面。</li></ol><p>这里应该注意到链表的插入是以<strong>头插法</strong>进行的。例如上面的&lt;K3,V3&gt;不是插在&lt;K2,V2&gt;后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值所在的桶</li><li>在链表上循序查找，时间复杂度显然与链表的长度成正比</li></ul><h4 id="HashMap核心成员变量"><a href="#HashMap核心成员变量" class="headerlink" title="HashMap核心成员变量"></a>HashMap核心成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXMUM_CAPACITY = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt; [] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ol><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小，16(索引0~15);</li><li>桶的最大值，2^30；</li><li>默认的负载因子（0.75）；</li><li>table是真正存放数据的数组；</li><li>size是Map的真实存放元素数量；</li><li>threshold，桶大小可在初始化时显式指定；</li><li>负载因子，可在初始化时显示指定。</li></ol><p>给定的默认容量为16，负载因子为0.75.Map在使用过程中不断的往里面存放数据，当数量达到了<code>16*0.75=12</code>时，就需要将当前16的容量进行扩容。而扩容这个操作设计rehash、复制数据等操作，所以非常消耗性能。</p><p><strong>因此通常建议能提前预估HashMap的大小，尽量的减少扩容带来的性能损耗。</strong></p><p>知晓了基本结构，下面来看看重要的put和get操作。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">  <span class="comment">//判断当前数组是否需要初始化</span></span><br><span class="line">  <span class="keyword">if</span>(table == EMPTY_TABLE)&#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//键为空时单独处理</span></span><br><span class="line">  <span class="keyword">if</span>(key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="comment">//确定桶下标</span></span><br><span class="line">  <span class="keyword">int</span>  i =  indexFor(hash, table.length);</span><br><span class="line">  <span class="comment">// 先找出是否已经存在键为key的键值对，如果存在的话就更新这个键值对的值为value，并返回原来的值</span></span><br><span class="line">  <span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e=e.next)&#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k=e.key) == key || key.equals(k)))&#123;</span><br><span class="line">      V oldValue = e.valu;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//插入新键值对</span></span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap允许插入键为null的键值对，但是因为无法调用null的hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap使用第0个桶存放键为null的键值对。</p><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex]))&#123;</span><br><span class="line">    <span class="comment">//如果需要就进行两倍扩容，并将当前的key重新hash并定位</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    hash = (<span class="keyword">null</span> != key)?hash(key):<span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line">  createEntry(hash, key, value, buckeyIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//头插法，链表头部指向新的键值对，将当前位置的桶传入新建的桶中。</span></span><br><span class="line">  table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> getForNullKey();</span><br><span class="line">  &#125;</span><br><span class="line">  Entry&lt;K, V&gt; entry = getEntry(key);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>)? <span class="number">0</span>:hash(key);</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">      e != <span class="keyword">null</span>; e = e.next)&#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key) || (key != <span class="keyword">null</span>) &amp;&amp; key.equals(k))</span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据key计算出hashCode，然后定位到具体的桶中；</p><p>判断该位置是否为链表；</p><p>不是链表就根据key，key的hashCode是否相等来返回值；</p><p>为链表则需要遍历直到key及hashCode相等时就返回值</p><p>啥都没取到就直接返回null。</p><h3 id="put操作中的一些小心机"><a href="#put操作中的一些小心机" class="headerlink" title="put操作中的一些小心机"></a>put操作中的一些小心机</h3><h4 id="计算hash值"><a href="#计算hash值" class="headerlink" title="计算hash值"></a>计算hash值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k instaceof String)&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  h ^= k.hashcode();</span><br><span class="line">  <span class="comment">//类似于扰动函数</span></span><br><span class="line">  h ^= (h&gt;&gt;&gt;<span class="number">20</span>) ^(h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^(h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><p>另x=1&lt;&lt;4,即x为2的四次方，它具有以下性质：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x  : <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">x-<span class="number">1</span>: <span class="number">0000</span> <span class="number">1111</span></span><br></pre></td></tr></table></figure><p>令一个数y与x-1做与运算，可以去除y位级表示的第四位以上数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y      : <span class="number">1011</span> <span class="number">0010</span></span><br><span class="line">x-<span class="number">1</span>    : <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">y&amp;(x-<span class="number">1</span>): <span class="number">0000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure><p>这个性质和y对x取模效果是一样的。我们知道，位运算的代价比求模运算小得多，因此在这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将key的hash值对桶个数取模：hash%capacity，如果能保证capacity为2的n次方，那么就可以将这个操作转换为位运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容基本原理"><a href="#扩容基本原理" class="headerlink" title="扩容基本原理"></a>扩容基本原理</h4><p>设HashMap的table长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为N/M，因此平均查找次数的复杂度为O(N/M).</p><p>为了让查找的成本降低，应该尽可能使得N/M尽可能小，因此需要保证M尽可能大，也就是说table要尽可能大。HashMap采用动态扩容来根据当前的N值来调整M值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数有：capacity，size，threshold和load_factor。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>capacity</td><td>table的容量大小，默认为16。capacity必须保证为2的n次方</td></tr><tr><td>size</td><td>键值对的数量</td></tr><tr><td>threshold</td><td>size的临界值，当size大于等于threshold就必须进行扩容操作</td></tr><tr><td>load_factor</td><td>装载因子，table能够使用的比例，threshold=capacity*load_factor</td></tr></tbody></table><p>当需要扩容时，令capacity为原来的两倍。扩容使用resize()实现，需要注意的是，扩容操作同样需要把oldTable的所有键值对重新插入到newTable中，因此这一步是非常费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">  <span class="keyword">if</span>(oldCapacity == MAXIMUM_CAPACITY)&#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">  transfer(newTable);</span><br><span class="line">  table = newTable;</span><br><span class="line">  threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span>&#123;</span><br><span class="line">  Entry[] src = table;</span><br><span class="line">  <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;src.length; j++)&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line">      src[j] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">        e.next = newTable[i];</span><br><span class="line">        newTable[i] = e;</span><br><span class="line">        e = next;</span><br><span class="line">      &#125;<span class="keyword">while</span>(e != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容-重新计算桶下标"><a href="#扩容-重新计算桶下标" class="headerlink" title="扩容-重新计算桶下标"></a>扩容-重新计算桶下标</h4><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap使用了一个特殊的机制。可以降低重新计算桶下标的操作。假设源数组长度为capacity为16，扩容之后new capacity为32.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity   : <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line">newCapacity: <span class="number">0010</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure><p>对于一个key，</p><ol><li>如果它的哈希值如果在第五位上为零，那么取模得到的结果和之前一样。</li><li>如果为1，那么得到的结果为原来的结果+16.</li></ol><h4 id="计算数组容量"><a href="#计算数组容量" class="headerlink" title="计算数组容量"></a>计算数组容量</h4><p>HashMap构造函数允许用户传入的容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。先考虑如何求一个数的掩码，对于10010000，它的掩码为11111111，可以使用如下方法得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1 1101 1000</span><br><span class="line">mask |= mask &gt;&gt; 2 1111 1110</span><br><span class="line">mask |= mask &gt;&gt; 4 1111 1111</span><br></pre></td></tr></table></figure><p>mask+1是大于原始数字的最小的2的n次方。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num     1001 0000</span><br><span class="line">mask+1 10000 0000</span><br></pre></td></tr></table></figure><p>一下是HashMap中计算数组容量的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">  <span class="comment">//为了避免cap本来就是2的n次方的情况</span></span><br><span class="line">  <span class="keyword">int</span> n = cap -<span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n&lt;<span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Base-1-8"><a href="#Base-1-8" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>1.7有一个很明显需要优化的点，当Hash冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低；时间复杂度为O(N). 因此1.8中重点优化了这个查询效率</p><p>和1.7大体上都差不多，有几个重要的区别：</p><ul><li>TREEIFY_THRESHOLD = 8, 用于判断是否需要将链表转换为红黑树的阈值；</li><li>HashEntry修改为Node。</li></ul><p>Node的核心组成和HashEntry一样，存放的都是key value hashCode next等数据。</p><p>其put操作要比1.7复杂一些：</p><ol><li>判断当前桶是否为空， 空的就需要初始化（resize中会判断是否进行初始化）</li><li>根据当前key的hashCode定位到具体的桶并判断是否为空，为空表明没有Hash冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（Hash冲突），那么就要比较当前桶中的key、key的hashCode于写入的key是否相等，相等就复制给e，然后统一返回。</li><li>如果当前桶为红黑树，那么就按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的key、value封装成一个新节点写入到<strong>当前桶的后面</strong>（形成链表）。（1.7是头插法）</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到key相同时直接退出遍历</li><li>如果e != null 就相当于存在相同的key，那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ol><p>get方法：</p><ol><li>首先将key hash之后取得所定位的桶。</li><li>如果桶为空直接返回null。</li><li>否则判断桶的第一个位置（有可能是链表、红黑树）的key是否为查询的key，是就直接返回value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方法返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ol><p>从这两个核心方法可以看出1.8对大链表做了优化，修改为红黑树之后查询效率直接提高到了<code>O(logn)</code>.</p><p>但是HashMap原有的问题也都存在，比如<strong>在并发场景下使用容易出现死循环</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HashMap扩容时会调用resize()方法，这里的并发操作容易在一个桶上形成<strong>环形链表</strong>；这样当获取一个key时，<strong>计算出的index正好是环形链表的下标就会出现死循环</strong>。</p><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>HashMap有以下几种遍历方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entryIterator = map.entryset().iterator();</span><br><span class="line"><span class="keyword">while</span>(entryIterator.hasNext())&#123;</span><br><span class="line">  Map.Entry&lt;String,String&gt; next = entryItreator.next();</span><br><span class="line">  System.out.println(<span class="string">"key="</span>+next.getKey() + <span class="string">" value="</span>+next.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  String key = iterator.next();</span><br><span class="line">  System.out.printlln(<span class="string">"key="</span> + key + <span class="string">" value="</span>+map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用第一种EntrySet进行遍历。</strong>第一种可以把key value同时取出，第二种还得需要通过key去一次value，效率较低。</p><p><strong>总结：</strong>无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p><p>下面就可以引入ConcurrentHashMap了。</p><h2 id="ConcurrentHashMap源码分析"><a href="#ConcurrentHashMap源码分析" class="headerlink" title="ConcurrentHashMap源码分析"></a>ConcurrentHashMap源码分析</h2><h3 id="Base1-7"><a href="#Base1-7" class="headerlink" title="Base1.7"></a>Base1.7</h3><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V value;</span><br><span class="line">  <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap和HashMap实现上类似，核心数据如value，以及链表都是由volatile修饰，保证了获取时的可见性。最主要的差别是ConcurrentHashMap采用了分段锁(Segment)，每个分段锁维护者几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是Segment的个数）。一个线程占用所访问一个Segment时，不会影响到其它的Segment。</p><p>Segment继承自ReentrantLock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = xxxxxxx;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES = </span><br><span class="line">    Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>?<span class="number">64</span>:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>默认的并发级别为16，也就是说默认创建16个Segment。</p><p><img src="https://img.moilk.top/img/zhen/2019-08-13-124117.png" alt="image-20190813204112100"></p><h4 id="2-用分离锁实现多个线程间的并发写操作"><a href="#2-用分离锁实现多个线程间的并发写操作" class="headerlink" title="2. 用分离锁实现多个线程间的并发写操作"></a>2. 用分离锁实现多个线程间的并发写操作</h4><p>在ConcurrentHashMap中，线程对映射表做读操作时，一般情况下不需要加锁就可以完成。对容器做结构性修改的操作才需要加锁。以put操作为例：</p><p>首先根据key计算出对应的hash值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> (value == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">  <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，根据hash值找到对应的Segment对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 key 的散列码来得到 segments 数组中对应的 Segment</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">  <span class="comment">//将散列值右移SegmentShift位，并在高位填充0</span></span><br><span class="line">  <span class="comment">//然后把得到的值与SegmentMask做与运算</span></span><br><span class="line">  <span class="comment">//从而得到hash值对应的Segment数组的下标值</span></span><br><span class="line">  <span class="comment">//最后根据下标值返回散列码对应的Segment对象</span></span><br><span class="line">  <span class="keyword">return</span> segments[(hash&gt;&gt;&gt; segmentShift) &amp; segmentMask];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在这个Segment中执行具体的put操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span></span>&#123;</span><br><span class="line">  <span class="comment">//加锁，这里是锁定某个Segment而非整个ConcurrentHashMap</span></span><br><span class="line">  lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果超过再散列的阈值，执行再散列，table数组的长度扩充一倍</span></span><br><span class="line">    <span class="keyword">if</span>(c++ &gt; threshold)&#123;</span><br><span class="line">      rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">    <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">    <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; (tab.length-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//找到散列码对应的具体的那个桶</span></span><br><span class="line">    HashEntry&lt;K, V&gt; first = tab[index];</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))&#123;</span><br><span class="line">      e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//如果键值对已经存在</span></span><br><span class="line">      oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span>(!onlyIfAbsent)&#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      oldValue = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);</span><br><span class="line">      count = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    unlock(); <span class="comment">//解锁</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 这里的加锁操作是真的（键的hash值对应的）某个具体的Segment，锁定的是该Segment而不是整个ConcurrentHashMap。因为插入键值对操作只是在Segment包含的某个桶中完成，不需要锁定整个ConcurrentHashMap。此时其他写线程对另外15个Segment的加锁并不会因为当前线程对这个Segment的加锁而阻塞。同时，所有读线程几乎不会因为本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry 的 value 域的值为 null，此时需要加锁后重新读取该值</code>）。</p><p>对比HashTable和由同步器包装的HashMap每次只能有一个线程执行读或写操作，ConCurrentHashMap在并发访问性能上有了质的提高。在理想状态下，ConCurrentHashMap可以支持16个线程执行并发写操作（如果并发级别设置为16），及任意数量线程的读操作。</p><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">  <span class="keyword">int</span> h = hash(key);</span><br><span class="line">  <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask &lt;&lt; SSHIFT) + SBASE);</span><br><span class="line">  <span class="keyword">if</span> (( s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span></span><br><span class="line">     &amp;&amp; (tab.s.table) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, ((<span class="keyword">long</span>)(((tab.length-<span class="number">1</span>) &amp; h)&lt;&lt; TSHIFT)+TBASE); </span><br><span class="line">        e != <span class="keyword">null</span>; e=e.next))&#123;</span><br><span class="line">      K k;</span><br><span class="line">      <span class="keyword">if</span>((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get逻辑比较简单，只需要将key通过Hash之后定位到具体的Segment，再通过一次Hash定位到具体的元素上。由于HashEntry中value属性是用volatile关键词修饰的，保证了内存可见性，所以每次获取到的都是最新值。</p><p>ConCurrentHashMap的get方法<strong>是非常高效的，因为整个过程都不需要加锁。</strong></p><h3 id="Base-1-8-1"><a href="#Base-1-8-1" class="headerlink" title="Base 1.8"></a>Base 1.8</h3><p>1.7已经解决了并发问题，并且能支持N个Segment的并发度，但是依然存在HashMap在1.7版本中的问题，即查询遍历链表效率太低。因此1.8做了一些数据结构上的调整。</p><p>底层的数据结构：</p><p><img src="https://img.moilk.top/img/zhen/2019-08-13-133625.png" alt="image-20190813213623283"></p><p>同时抛弃了原有的Segment分段锁，而采用了<strong>CAS+synchronized</strong>来保证并发安全性。</p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li>根据key计算出hashCode；</li><li>判断是否需要进行初始化</li><li>f即为当前key定位出的Node，如果为空表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功；</li><li>如果当前位置的hashCode == MOVED == -1，则需要进行扩容。</li><li>如果都不满足，则利用synchronized锁写入数据。</li><li>如果数量大于TREEIFY_THRESHOLD则要转换为红黑树。</li></ol><h4 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h4><ol><li>根据计算出来hashCode寻址，如果就在桶上那么就直接返回值。</li><li>如果是红黑树那么按照树的额方式获取值。</li><li>都不满足就按照链表的方式遍历获取值。</li></ol><p>1.8在1.7的数据结构上做了大的改动，采用红黑树之后可以保证查询效率O(logn),甚至取消了ReentrantLock改为了synchronized，这样可以看出在新版的JDK中对synchronized优化是很到位的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你! </a></p><p>[2] <a href="[https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 容器.md">技术面试必备基础知识 </a>)</p><p>[3] <a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Map这样的&lt;code&gt;Key Value&lt;/code&gt;在软件开发中是非常经典的结构，常用于在内存中存放数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h3&gt;&lt;p&gt;众所周知HashMap底层是基于&lt;code&gt;数组+链表&lt;/code&gt;组成的，不过jdk1.7和1.8中实现稍有不同，为了便于理解，以下源码分析以JDK1.7为主&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://izhen.tech/categories/Java/"/>
    
    
      <category term="HashMap" scheme="http://izhen.tech/tags/HashMap/"/>
    
      <category term="ConcurrentHashMap" scheme="http://izhen.tech/tags/ConcurrentHashMap/"/>
    
      <category term="源码" scheme="http://izhen.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动18年后端方向笔试真题</title>
    <link href="http://izhen.tech/2019/08/12/%E5%AD%97%E8%B7%B318%E5%B9%B4%E7%9C%9F%E9%A2%98/"/>
    <id>http://izhen.tech/2019/08/12/字跳18年真题/</id>
    <published>2019-08-12T08:20:21.000Z</published>
    <updated>2019-08-13T00:40:23.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字跳18年后端方向"><a href="#字跳18年后端方向" class="headerlink" title="字跳18年后端方向"></a>字跳18年后端方向</h2><h3 id="🥇用户喜好"><a href="#🥇用户喜好" class="headerlink" title="🥇用户喜好"></a>🥇用户喜好</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&lt;=L2&lt;=R2&lt;=R1)。</p></blockquote><a id="more"></a><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数  第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l&lt;=i&lt;=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n &lt;= 300000,q&lt;=300000 k是整型</p></blockquote><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>输出：一共q行，每行一个整数代表喜好值为k的用户的个数</p></blockquote><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这题的题目很长，容易把人弄晕。给了一个数组，其中索引i对应的值代表员工编号为i的喜好值val；然后给一个查询条件，员工编号的范围[l, r],以及喜好值k，判断在这个范围内有多少喜好值为k的员工。我们输出打印员工的人数即可。</p><p>看到这题，就觉得简直不能更简单了好么！用一个数组把员工的喜好值存起来，再用一个for循环遍历索引为[left,right]中的喜好值即可。无奈理想很丰满，现实很骨感，一提交运行就给你一个50%的通过率，原因是超时。可能是员工的人数过多，但喜好值呢，是一个比较固定的范围。</p><p>因此想办法改进，很直观的方法是用一个map把喜好和员工编号对应起来，每次查询找到喜好值为k的所有员工，员工的编号是有序的，二分查找所有在范围内的员工即可。二分查找时，找到大于等于员工编号左边界的最小值，和小于等于员工编号的最大值，根据二者的差值求出员工数目。</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">      HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//将喜好为k的员工放在一起</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = in.nextInt();</span><br><span class="line">        <span class="comment">//这种输入方法可以记一下，一个key对应一个列表的情况</span></span><br><span class="line">        List&lt;Integer&gt; tmp = map.getOrDefault(k, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        tmp.add(i);</span><br><span class="line">        map.put(k, tmp);        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> q = in.nextInt();</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> right = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> target = in.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target))&#123;</span><br><span class="line">          List&lt;Integer&gt; list = map.get(target);</span><br><span class="line">          <span class="comment">//把Integer类型传进去</span></span><br><span class="line">          Integer[] array = list.toArray(Integer[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">int</span> start = lowerBound(array, target);</span><br><span class="line">          <span class="keyword">int</span> end = upperBound(array, target);</span><br><span class="line">          <span class="keyword">if</span>(start != -<span class="number">1</span> &amp;&amp; end != -<span class="number">1</span>)&#123;</span><br><span class="line">            res = end - start +<span class="number">1</span>;</span><br><span class="line">          &#125;                   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//找到大于等于target的最小值</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(Integer[] array, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">      <span class="keyword">if</span>(target &lt;= array[mid])&#123;</span><br><span class="line">        r = mid-<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l = mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; array.length &amp;&amp; array[l] &gt;= target)&#123;</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//找到小于等于target的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(Integer[] array, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">      <span class="keyword">if</span>(target &gt;= array[mid])&#123;</span><br><span class="line">        l = mid+<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r = mid-<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; array[r] &lt;= target)&#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🥈手串"><a href="#🥈手串" class="headerlink" title="🥈手串"></a>🥈手串</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>作为一个手串艺人，有金主向你订购了一条包含n个杂色串珠的手串——每个串珠要么无色，要么涂了若干种颜色。为了使手串的色彩看起来不那么单调，金主要求，手串上的任意一种颜色（不包含无色），在任意连续的m个串珠里至多出现一次（注意这里手串是一个环形）。手串上的颜色一共有c种。现在按顺时针序告诉你n个串珠的手串上，每个串珠用所包含的颜色分别有哪些。请你判断该手串上有多少种颜色不符合要求。即询问有多少种颜色在任意连续m个串珠中出现了至少两次.</p></blockquote><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>第一行输入n，m，c三个数，用空格隔开。(1 &lt;= n &lt;= 10000, 1 &lt;= m &lt;= 1000, 1 &lt;= c &lt;= 50) 接下来n行每行的第一个数num_i(0 &lt;= num_i &lt;= c)表示第i颗珠子有多少种颜色。接下来依次读入num_i个数字，每个数字x表示第i颗柱子上包含第x种颜色(1 &lt;= x &lt;= c)</p></blockquote><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><blockquote><p>一个非负整数，表示该手链上有多少种颜色不符需求。</p></blockquote><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>这个题目也很绕，搞得人看不明白就对了。我一度觉得自己智商有问题。给一个手串，手串上有n个珠子，总共有c种颜色，每个珠子可能由0种或多种颜色组成，规则为连续m个珠子中出现了至少两次则这种颜色不符合要求。</p><p>我们把题目转换一下，有一个数组，索引i指的是颜色i，每个里面放的是所有出现了的珠子位置，然后判断每个颜色里面的珠子是否是符合要求的。</p><p>注意：这里要输出的是有<strong>多少种颜色</strong>不符合需求，因此每种颜色只要出现了一组不符合要求的位置就可以退出了。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> C = in.nextInt();</span><br><span class="line">        List&lt;Integer&gt;[] position = <span class="keyword">new</span> List&lt;&gt;[C+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">           position[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N;i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> c= in.nextInt();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;c;j++)&#123;</span><br><span class="line">            position[j].add(i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;=C;i++)&#123;</span><br><span class="line">          <span class="comment">//手链是环形</span></span><br><span class="line">          <span class="keyword">if</span>(position[i].get(<span class="number">0</span>)+N-position[position[i].size()-<span class="number">1</span>] &lt; M)&#123;</span><br><span class="line">              count++;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;position[i].size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(position[i].get(j+<span class="number">1</span>) - position[i].get[j] &lt; M)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      System.out.println(count);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字跳18年后端方向&quot;&gt;&lt;a href=&quot;#字跳18年后端方向&quot; class=&quot;headerlink&quot; title=&quot;字跳18年后端方向&quot;&gt;&lt;/a&gt;字跳18年后端方向&lt;/h2&gt;&lt;h3 id=&quot;🥇用户喜好&quot;&gt;&lt;a href=&quot;#🥇用户喜好&quot; class=&quot;headerlink&quot; title=&quot;🥇用户喜好&quot;&gt;&lt;/a&gt;🥇用户喜好&lt;/h3&gt;&lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&amp;lt;=L2&amp;lt;=R2&amp;lt;=R1)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔试" scheme="http://izhen.tech/categories/%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="字节跳动" scheme="http://izhen.tech/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="真题" scheme="http://izhen.tech/tags/%E7%9C%9F%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>索引及其背后的数据结构支持</title>
    <link href="http://izhen.tech/2019/08/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://izhen.tech/2019/08/11/数据库索引及其算法/</id>
    <published>2019-08-11T08:41:04.000Z</published>
    <updated>2019-09-13T09:35:46.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引及其背后的数据结构支持"><a href="#索引及其背后的数据结构支持" class="headerlink" title="索引及其背后的数据结构支持"></a>索引及其背后的数据结构支持</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时。</p><p>数据库查询是数据库最主要的功能之一.</p><p>如果想要理解MySQL中索引是如何工作的，最简单的方法就是去看看一本书的“目录”部分：如果想在一本书中找到某个索引，一般会先看书的“目录”，找到对应的页码。</p><a id="more"></a><h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>目前大部分数据库系统及文件系统都采用B-Tree或者B+Tree作为索引结构。这是有一定原因的。首先介绍其数据结构。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key，data]，key为记录的键值，对应不同的数据记录，key是互不相同的。data为数据记录出key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ul><li><p>d为大于1的一个正整数，称为B-Tree的度。</p></li><li><p>h为一个正整数，称为B-Tree的高度。</p></li><li><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d.</p></li><li><p>每个叶子节点最少包含一个key和两个指针，最多包含2n-1个key和2d个指针，叶节点的指针均为null。</p></li><li><p>所有叶节点具有相同的深度，等于树高h。</p></li><li><p>key和指针互相间隔，节点两端是指针。</p></li><li><p>一个节点中的key从左到右非递减排列[非严格递增]。</p></li><li><p>所有节点组成树结构。</p></li><li><p>每个指针要么为null，要么指向另外一个节点。</p></li></ul><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v（key1），其中v(key1)为node的第一个key的值。(隐隐有点像二叉搜索树，左边比根节点小。右边比根节点大)</p><p>如果某个指针在节点node的最右边且不为null，则其指向节点的所有key大于v（keym），其中v(keym)为node的最后一个key的值。</p><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)；</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-110018.png" alt="image-20190812185914569"></p><p>图为一个d=2的B-Tree示意图，d为2指的是每个指针有两个数据，20，49是大于15且小于56的。</p><h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>MySQL普遍使用B+Tree实现其索引结构。与B-Tree相比，B+tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1</li><li>内节点不存储data，只存储key；叶子节点不存储指针；</li></ul><p>下面是一个简单B+Tree示意：</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-110824.png" alt="image-20190812190819255"></p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p><h4 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h4><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-111159.png" alt="image-20190812191156521"></p><p>如图所示，在B+Tree中的每个叶子节点增加一个指向相邻叶子节点的指针，这样就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4要查询key从18到49顶点所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p><h3 id="为什么使用B-Tree"><a href="#为什么使用B-Tree" class="headerlink" title="为什么使用B+Tree"></a>为什么使用B+Tree</h3><p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这是为什么呢？</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中中就要产生磁盘IO消耗，相对于内存存取，IO存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是<strong>查找过程中磁盘IO操作次数。</strong></p><p>根据B-Tree的定义，可知检索一次最多需要访问h个节点，数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次IO就可以完全载入了。为了达到这个目的，在实际实现中还需要如下技巧：</p><ul><li>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次IO；</li><li>B-Tree中一次索引最多需要h-1次IO，根节点常驻内存，渐进复杂度O(h)=O(logdN).一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小，通常不超3.</li></ul><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h明显要深得多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用数据的局部性，所以红黑树的IO渐进复杂度为O(h),效率明显比B-Tree差很多。</p><p>除此之外，B+Tree更适合外存索引，原因和内节点出度d有关。由上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小。</p><p>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><p>不同存储引起对索引的实现方式是不同的，这里主要介绍MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-113652.png" alt="image-20190812193647976"></p><p>这里假设表一共有三列，假设我们以col1为主键，则图8是一个MyISAM表的主索引示意。可以看出，MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-114032.png" alt="image-20190812194027786"></p><p>注意看辅助索引的和主索引的差别，辅助索引叶子节点存放的key是辅助字段的值，而主索引叶子节点存放的key是主键的值。</p><p>因此MyISAM中索引检索的算法首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应的数据记录。</p><p>MyISAM的索引方式也叫做非聚集索引。</p><h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但实现方式却与MyISAM截然不同。</p><p>第一个重大区别就是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据文件的地址。而在InnoDB中，表数据文件本身就是按B+tree组织的一个索引结构。这颗树的叶节点data域保存了完整的数据记录，这个索引的key是数据表的主键。</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-115607.png" alt="image-20190812195606518"></p><p>图10是InnoDB主索引(同时也是数据文件)的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><p>第二个与MyISAM索引不同的是InnoDB的<strong>辅助索引</strong>data域存储相应记录<strong>主键的值</strong>而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。如下图所示：</p><p><img src="https://img.moilk.top/img/zhen/2019-08-12-120152.png" alt="image-20190812200148892"></p><p>聚集索引这种实现方式使得按主键搜索十分高效，但是辅助索引搜索需要检索两遍索引：通过辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是一个好主意，因为InnoDB数据本间本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><h2 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h2><p>MySQL的优化主要分为结构优化和查询优化。本章讨论的高性能索引策略主要属于结构化优化范围。</p><h3 id="最长前缀原理与相关优化"><a href="#最长前缀原理与相关优化" class="headerlink" title="最长前缀原理与相关优化"></a>最长前缀原理与相关优化</h3><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关。主键有三个<code>emp_no, title, from_date</code>.</p><h4 id="情况一：全列匹配"><a href="#情况一：全列匹配" class="headerlink" title="情况一：全列匹配"></a>情况一：全列匹配</h4><p>很明显，当按照索引中的所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引。 </p><h4 id="情况二：最左前缀匹配"><a href="#情况二：最左前缀匹配" class="headerlink" title="情况二：最左前缀匹配"></a>情况二：最左前缀匹配</h4><p>当查询条件精确匹配索引的左边连续一个或几个列时，索引可以被用到，但是只用到一部分，即条件所组成的最左前缀。</p><h4 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h4><p>此时索引使用情况和情况二相同，因为title未提供，所以<strong>查询只用到了索引的第一列</strong>，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要<strong>对结果进行扫描过滤</strong>from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><h4 id="情况四：查询条件没有指定索引第一列"><a href="#情况四：查询条件没有指定索引第一列" class="headerlink" title="情况四：查询条件没有指定索引第一列"></a>情况四：查询条件没有指定索引第一列</h4><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h4 id="情况五：匹配某列的前缀字符串"><a href="#情况五：匹配某列的前缀字符串" class="headerlink" title="情况五：匹配某列的前缀字符串"></a>情况五：匹配某列的前缀字符串</h4><p><code>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#39;10001&#39; AND title LIKE &#39;Senior%&#39;;</code></p><p>如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。</p><h4 id="情况六：范围查询"><a href="#情况六：范围查询" class="headerlink" title="情况六：范围查询"></a>情况六：范围查询</h4><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><h4 id="情况七：查询条件中含有函数或表达式"><a href="#情况七：查询条件中含有函数或表达式" class="headerlink" title="情况七：查询条件中含有函数或表达式"></a>情况七：查询条件中含有函数或表达式</h4><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引(虽然某些在数学意义上可以使用)。由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h3 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h3><p>既然索引可以加快查询速率，是不是只要是查询语句就建上索引？答案是否定的，因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行中也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引：</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描好了。至于多少条记录才算多，这个人有个人的看法，记录数不超过2000可以考虑不建索引，超过2000条才可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性是指不重复的索引值与表记录数的比值。显然选择性的取值范围为(0,1],选择性越高的索引价值越大，这是由B+Tree的性质决定。</p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时应为索引key变短而减少了索引文件的大小和维护开销。</p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）</p><h3 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h3><p>在使用InnoDB存储引擎时，<strong>如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</strong></p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主机那将其插入到适当的节点和位置，如果页面到达装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如身份证或学号等）由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置。</p><p>因此MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能被回写到磁盘上而从缓存中清掉，此时又要从磁盘中读回来。这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段作为主键。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引及其背后的数据结构支持&quot;&gt;&lt;a href=&quot;#索引及其背后的数据结构支持&quot; class=&quot;headerlink&quot; title=&quot;索引及其背后的数据结构支持&quot;&gt;&lt;/a&gt;索引及其背后的数据结构支持&lt;/h2&gt;&lt;h3 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h3&gt;&lt;p&gt;索引是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时。&lt;/p&gt;
&lt;p&gt;数据库查询是数据库最主要的功能之一.&lt;/p&gt;
&lt;p&gt;如果想要理解MySQL中索引是如何工作的，最简单的方法就是去看看一本书的“目录”部分：如果想在一本书中找到某个索引，一般会先看书的“目录”，找到对应的页码。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://izhen.tech/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://izhen.tech/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="B+树" scheme="http://izhen.tech/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://izhen.tech/2019/07/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://izhen.tech/2019/07/24/单例模式/</id>
    <published>2019-07-24T13:45:09.000Z</published>
    <updated>2019-09-13T09:35:46.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例Singleton"><a href="#单例Singleton" class="headerlink" title="单例Singleton"></a>单例Singleton</h2><p>确保一个类只有一个实例，并提供该实例的全局访问点。Singleton通常被用来代表那些本质上唯一的系统组件，比如<strong>窗口管理器或者文件系统</strong>。</p><p>使用一个<strong>私有构造函数，一个私有静态变量以及一个公有静态函数</strong>来实现。私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。<br><a id="more"></a></p><h3 id="最简单的单例实现：饿汉模式"><a href="#最简单的单例实现：饿汉模式" class="headerlink" title="最简单的单例实现：饿汉模式"></a>最简单的单例实现：饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//类装载的时候已经初始化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">//构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">  <span class="comment">//提供公有的获取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式虽然不是最好的实现方式，但是是最常用的单例的实现方式。因为类一开始即被装载，所以不用担心线程安全的问题。但是缺点就是如果不使用这个类，就会存在内存浪费的问题。</p><h3 id="线程安全：双重检查模式"><a href="#线程安全：双重检查模式" class="headerlink" title="线程安全：双重检查模式"></a>线程安全：双重检查模式</h3><p>加锁操作只需要对实例化部分的代码进行，只有当instance没有被实例化时，才需要进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//volatile的申明作用是内存变量共享，和禁止指令重排序</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single instance;</span><br><span class="line">  <span class="comment">//构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="comment">//提供公有的获取方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在锁的内部还有再加一层if判断呢，如果只有一个if语句，在instance==null的情况下，如果两个线程都进入了if语句块中，虽然在if语句块中有加锁操作，但两个线程都会执行实例化<code>instance= new Singleton()</code>这条语句，只是时间问题。那么就会进行两次实例化。破坏了单例模式。因此需要两个if语句：第一个语句用来避免instance已经被实例化后的加锁操作，第二个if语句进行了加锁，只有一个线程进入，不会出现多次实例化的情况。</p><h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><p>当Singleton类被加载时，静态内部类SingletonHolder没有被加载进内存。只有当调用getInstance()方法时从而触发SingletonHolder.instance时SingletonHolder才会被加载。此时初始化INSTANCE实例，并且<strong>JVM确保INSTANCE只能被实例化一次。</strong></p><p>这种方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="comment">//静态内部类不会在一开始被装载，所以没有内存消耗的问题</span></span><br><span class="line">  <span class="comment">//JVM在装载静态内部类是线程安全的，只有在使用内部类才会去装载，所以线程是安全的</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTNCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM装载内部类并不是程序启动就装载，而且装载内部类是线程安全的。所以这个单例模式真正意义上实现了懒加载与线程安全且节省了内存。</p><h3 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h3><p>实现单例模式只需编写一个包含单个元素的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateInstance</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁，且无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。可以防止反射攻击，防止反序列化重新创建新的对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Effective Java 中文版</p><p>[2] 技术面试必备基础知识 </p><p>[3] <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247484279&amp;idx=1&amp;sn=5c119c82038686c85570c4adf1511cc6&amp;chksm=fdded5b3caa95ca5f5b3bcfb636a67fe35a48ed6449162eafc89dc1ca0d970ab4e79b179347f&amp;mpshare=1&amp;scene=23&amp;srcid=08142mvZInYGTWDibuHY9qHP&amp;sharer_sharetime=1565748070691&amp;sharer_shareid=0a9c585f82185ac6442d5cc5cd84d6ac#rd" target="_blank" rel="noopener">CodeSheep单例模式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例Singleton&quot;&gt;&lt;a href=&quot;#单例Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例Singleton&quot;&gt;&lt;/a&gt;单例Singleton&lt;/h2&gt;&lt;p&gt;确保一个类只有一个实例，并提供该实例的全局访问点。Singleton通常被用来代表那些本质上唯一的系统组件，比如&lt;strong&gt;窗口管理器或者文件系统&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用一个&lt;strong&gt;私有构造函数，一个私有静态变量以及一个公有静态函数&lt;/strong&gt;来实现。私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://izhen.tech/categories/Java/"/>
    
    
      <category term="单例模式" scheme="http://izhen.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://izhen.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>部署Java项目</title>
    <link href="http://izhen.tech/2019/06/28/Java%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <id>http://izhen.tech/2019/06/28/Java部署自己的项目在服务器上/</id>
    <published>2019-06-28T06:44:04.000Z</published>
    <updated>2019-06-28T07:59:57.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何部署自己的项目在服务器上"><a href="#如何部署自己的项目在服务器上" class="headerlink" title="如何部署自己的项目在服务器上"></a>如何部署自己的项目在服务器上</h2><blockquote><p>主要是点来点去的。   </p></blockquote><h3 id="一、登录服务器"><a href="#一、登录服务器" class="headerlink" title="一、登录服务器"></a>一、登录服务器</h3><p>点击IDEA菜单栏的<code>tools</code>-&gt;<code>Deplment</code>，输入服务器的账号和密码，测试一下，查看是否连接成功。这里连接道康服务器，之前已经输入过账号和密码，连接成功。</p><p><code>tools</code>-&gt;<code>start SSH session</code>,终端进入道康服务器。</p><p>输入指令<code>ps aux | grep visualcensus</code>过滤查找之前运行的进程号。</p><p>杀死之前的那个进程<code>kill 1215</code>，1215为上面查找的进程id。</p><a id="more"></a><h3 id="二、打包"><a href="#二、打包" class="headerlink" title="二、打包"></a>二、打包</h3><p>当然要配合数据库，但是因为男神操作太快，这里就没能记录下来。</p><p>右侧边状态栏，点击<code>Maven</code>，在<code>Lifecycle</code>中点击<code>package</code>，将整个项目打包。等待打包完成。</p><h3 id="三、上传"><a href="#三、上传" class="headerlink" title="三、上传"></a>三、上传</h3><p>直接将打包好的额target包下面的<code>.jar</code>文件用鼠标拖到<code>Remote Host</code>中的visualcensus中，在命令行输入<code>nohup java -jar visualcensusserver-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;</code>y运行java工程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何部署自己的项目在服务器上&quot;&gt;&lt;a href=&quot;#如何部署自己的项目在服务器上&quot; class=&quot;headerlink&quot; title=&quot;如何部署自己的项目在服务器上&quot;&gt;&lt;/a&gt;如何部署自己的项目在服务器上&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要是点来点去的。   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、登录服务器&quot;&gt;&lt;a href=&quot;#一、登录服务器&quot; class=&quot;headerlink&quot; title=&quot;一、登录服务器&quot;&gt;&lt;/a&gt;一、登录服务器&lt;/h3&gt;&lt;p&gt;点击IDEA菜单栏的&lt;code&gt;tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Deplment&lt;/code&gt;，输入服务器的账号和密码，测试一下，查看是否连接成功。这里连接道康服务器，之前已经输入过账号和密码，连接成功。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tools&lt;/code&gt;-&amp;gt;&lt;code&gt;start SSH session&lt;/code&gt;,终端进入道康服务器。&lt;/p&gt;
&lt;p&gt;输入指令&lt;code&gt;ps aux | grep visualcensus&lt;/code&gt;过滤查找之前运行的进程号。&lt;/p&gt;
&lt;p&gt;杀死之前的那个进程&lt;code&gt;kill 1215&lt;/code&gt;，1215为上面查找的进程id。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://izhen.tech/categories/Java/"/>
    
    
      <category term="deployment" scheme="http://izhen.tech/tags/deployment/"/>
    
  </entry>
  
  <entry>
    <title>24题一组数据交换相邻节点</title>
    <link href="http://izhen.tech/2019/03/01/24%E9%A2%98%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E8%8A%82%E7%82%B9/"/>
    <id>http://izhen.tech/2019/03/01/24题一组数据交换相邻节点/</id>
    <published>2019-03-01T08:49:57.000Z</published>
    <updated>2019-03-01T09:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交换相邻节点"><a href="#交换相邻节点" class="headerlink" title="交换相邻节点"></a>交换相邻节点</h2><blockquote><p>难度：中等     思路：递归     </p></blockquote><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><a id="more"></a> <p><strong>示例:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><p>链表中节点的交换是传统问题，两个指针解决问题，唯一要注意的是不能在交换过程中把链表给断开了，否则岂不是得不偿失？暴力法本可以解决一切，但是优雅的方法是递归，把相邻节点的交换搞定，然后递归把所有的节点串起来，简直是美滋滋啊。</p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span>        </span><br><span class="line">        <span class="comment"># 防止只有一个节点或没有节点时报错</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.next:</span><br><span class="line">            p = head</span><br><span class="line">            q = head.next</span><br><span class="line">            head = q</span><br><span class="line">            <span class="comment"># 第一次交换不需要考虑与前面的连接 三步法连接</span></span><br><span class="line">            p.next = q.next</span><br><span class="line">            q.next = p </span><br><span class="line">            <span class="comment"># 开始递归</span></span><br><span class="line">            p.next = self.swapPairs(p.next)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交换相邻节点&quot;&gt;&lt;a href=&quot;#交换相邻节点&quot; class=&quot;headerlink&quot; title=&quot;交换相邻节点&quot;&gt;&lt;/a&gt;交换相邻节点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：中等     思路：递归     &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h3&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你不能只是单纯的改变节点内部的值&lt;/strong&gt;，而是需要实际的进行节点交换。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="递归" scheme="http://izhen.tech/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="http://izhen.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="交换" scheme="http://izhen.tech/tags/%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>23题合并k个有序的链表</title>
    <link href="http://izhen.tech/2019/03/01/23%E9%A2%98%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://izhen.tech/2019/03/01/23题合并k个有序的链表/</id>
    <published>2019-03-01T08:11:22.000Z</published>
    <updated>2019-03-01T09:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并K个有序的链表"><a href="#合并K个有序的链表" class="headerlink" title="合并K个有序的链表"></a>合并K个有序的链表</h2><blockquote><p>难度： hard模式                                   思路：优先级队列</p></blockquote><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><p>首先是hard模式，说明不能轻易的解决这个问题。认真思考了一个小时，觉得已经理清楚思路，然而苦于不知该如何实现自己的思路。试了几种方法，反而是原地打转，于是决定参考一下答案。答案实现了我的思路，原来使用了一种之前没有用过的数据结构，优先级队列(<code>PrivirotyQueue</code>),这一篇<a href="https://zhuanlan.zhihu.com/p/37637660" target="_blank" rel="noopener">专栏</a>简单介绍了优先级队列，对于理解这题，简直是正中靶心。</p><p>思路如下：</p><p>用三个指针指向k个链表的头部，比较指针中的值，将最小的值加入到结果中，然后指针后移，直到所有的指针为空。由于是列表，无法直接得到所有链表的头部，所以只能通过优先级队列来做。遍历列表，将头指针和头指针的val组成一个元组入队列，出队列时头指针的val作为评判其优先级的标准。<strong>注意事项，当队列中的元组优先级(即头指针的val)相同时，将会把指针这个对象作为比较优先级的评判标准</strong>，但是对象在python中是不能直接比较的，会引起代码崩溃，元组之间的元素用逗号隔开，不能有空格，否则代码也会崩溃。</p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue <span class="keyword">as</span> PQ</span><br><span class="line"><span class="comment"># 导入优先级队列的包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        pq = PQ()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                <span class="comment"># 当列表的优先级相同(即val相等）时，由元祖中的第二个元素确定优先级，</span></span><br><span class="line">                <span class="comment"># 而链表是对象不能直接确定优先级，所以加入一个变化的下标作为优先级避免程序崩溃</span></span><br><span class="line">                pq.put((l.val,index,l))</span><br><span class="line">                index += <span class="number">1</span>                        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> pq.empty():</span><br><span class="line">            val,index, node = pq.get() </span><br><span class="line">            <span class="comment"># 不能直接操作point，会导致链表的断裂</span></span><br><span class="line">            point.next = node</span><br><span class="line">            point = point.next</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node != <span class="keyword">None</span>:</span><br><span class="line">                pq.put((node.val,index,node))</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p><strong>O(N log k) </strong>:比较大小的时间花费将被减少到O(log k)，因为优先级队列的内部实现机制用到了堆，但是找到最小值的节点仅仅花费 O(1)， 在最终的链表中有K个节点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;合并K个有序的链表&quot;&gt;&lt;a href=&quot;#合并K个有序的链表&quot; class=&quot;headerlink&quot; title=&quot;合并K个有序的链表&quot;&gt;&lt;/a&gt;合并K个有序的链表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度： hard模式                                   思路：优先级队列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h3&gt;&lt;p&gt;合并 &lt;em&gt;k&lt;/em&gt; 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="优先级队列，链表" scheme="http://izhen.tech/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>21题有序链表的合并</title>
    <link href="http://izhen.tech/2019/02/22/21%E9%A2%98%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://izhen.tech/2019/02/22/21题合并两个有序链表/</id>
    <published>2019-02-22T09:37:03.000Z</published>
    <updated>2019-03-01T09:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode刷题之21题有序链表的合并"><a href="#LeetCode刷题之21题有序链表的合并" class="headerlink" title="LeetCode刷题之21题有序链表的合并"></a>LeetCode刷题之21题有序链表的合并</h2><blockquote><p>难度：easy                                  思路：硬算</p></blockquote><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><p>有序链表的合并是归并排序中的经典算法，这题采用常规思路即可解决问题，唯一要注意的点是当指针p、q中任一指针为空时后续应该如何操作。</p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2,)</span>:</span></span><br><span class="line">p = l1 </span><br><span class="line">    q = l2</span><br><span class="line">    head = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># p q均不为空</span></span><br><span class="line">    <span class="keyword">while</span> p != <span class="keyword">None</span> <span class="keyword">and</span> q != <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">if</span>  p.val &lt;= q.val :</span><br><span class="line">            <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">                head = p</span><br><span class="line">                n = p</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n.next = p</span><br><span class="line">                n = n.next</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">                head = q</span><br><span class="line">                n = q</span><br><span class="line">                q = q.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n.next = q</span><br><span class="line">                n = n.next</span><br><span class="line">                q = q.next</span><br><span class="line">    <span class="comment"># p q中任一为空 将p指定为非空 直接将p后面的节点连在n的后面</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q !=<span class="keyword">None</span>:</span><br><span class="line">        p = q</span><br><span class="line">        q = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">        head = p</span><br><span class="line">        n = p</span><br><span class="line">    <span class="keyword">else</span>:            </span><br><span class="line">        n.next = p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>时间复杂度分析：</p><p><strong>O(M+N)       M为l1链表的长度，N为l2链表的长度</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode刷题之21题有序链表的合并&quot;&gt;&lt;a href=&quot;#LeetCode刷题之21题有序链表的合并&quot; class=&quot;headerlink&quot; title=&quot;LeetCode刷题之21题有序链表的合并&quot;&gt;&lt;/a&gt;LeetCode刷题之21题有序链表的合并&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：easy                                  思路：硬算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h3&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://izhen.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题之20题有效的括号</title>
    <link href="http://izhen.tech/2019/02/22/20%E9%A2%98%E6%8B%AC%E5%8F%B7%E7%9A%84%E9%85%8D%E5%AF%B9/"/>
    <id>http://izhen.tech/2019/02/22/20题括号的配对/</id>
    <published>2019-02-22T09:23:53.000Z</published>
    <updated>2019-03-01T08:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode刷题之20题有效的括号"><a href="#LeetCode刷题之20题有效的括号" class="headerlink" title="LeetCode刷题之20题有效的括号"></a>LeetCode刷题之20题有效的括号</h2><blockquote><p>难度：简单                                   思路：栈</p></blockquote><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><a id="more"></a><p>示例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><p>这是一题难度为简单的题，但我仍旧很久没有思路，就是没有想到利用栈的特性，本题是一道经典的栈的特性的题目，想到栈，就成功了一大半。</p><h3 id="三、-代码分析"><a href="#三、-代码分析" class="headerlink" title="三、 代码分析"></a>三、 代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    res = <span class="keyword">True</span></span><br><span class="line">    stack = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack: <span class="comment"># 栈为空</span></span><br><span class="line">            stack.append(element) </span><br><span class="line">            <span class="comment"># 利用栈的先进后出的特点，判断列表的尾部即栈的头部的元素情况</span></span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>] == <span class="string">'('</span> <span class="keyword">and</span> element == <span class="string">')'</span>:</span><br><span class="line">            stack.pop() <span class="comment"># 出栈在栈的头部</span></span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>] == <span class="string">'['</span> <span class="keyword">and</span> element == <span class="string">']'</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> stack[<span class="number">-1</span>] == <span class="string">'&#123;'</span> <span class="keyword">and</span> element == <span class="string">'&#125;'</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(element) <span class="comment"># 进栈也在栈的头部</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断栈是否为空，为空则说明括号是对称有效</span></span><br><span class="line">        <span class="keyword">if</span> stack :</span><br><span class="line">            res = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            res = <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p><strong>O(N)           N为字符串的长度</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode刷题之20题有效的括号&quot;&gt;&lt;a href=&quot;#LeetCode刷题之20题有效的括号&quot; class=&quot;headerlink&quot; title=&quot;LeetCode刷题之20题有效的括号&quot;&gt;&lt;/a&gt;LeetCode刷题之20题有效的括号&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：简单                                   思路：栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h3&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;{&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;}&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;]&amp;#39;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="栈" scheme="http://izhen.tech/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>19题删除链表的指定节点</title>
    <link href="http://izhen.tech/2019/02/18/19%E9%A2%98%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0N%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://izhen.tech/2019/02/18/19题删除链表倒数N的节点/</id>
    <published>2019-02-18T06:45:30.000Z</published>
    <updated>2019-03-01T09:10:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除链表的指定节点"><a href="#删除链表的指定节点" class="headerlink" title="删除链表的指定节点"></a>删除链表的指定节点</h2><blockquote><p>难度：中等         思路：窗口法</p></blockquote><h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。</p><p>示例：</p><blockquote><p>给定一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p><strong>说明</strong>：给定的n保证是有效的。</p><a id="more"></a><p><strong>进阶：</strong>你能尝试一趟扫描实现吗？</p><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><h4 id="2-1-逻辑梳理"><a href="#2-1-逻辑梳理" class="headerlink" title="2.1 逻辑梳理"></a>2.1 逻辑梳理</h4><p>本题和链表有关，链表是最基本的数据结构，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。链表的优势在于插入和删除元素，可以快速完成而不需要移动其他元素。链表由一个个节点组成，节点有两部分，节点的值和下一个节点的地址，尾节点的下一个节点的地址为空。在Python中即<code>None</code>，想要通过一趟扫描删除倒数第n个节点，最有效的方法就是窗口法，指针<code>p，q</code>之间间隔n个节点，然后指针<code>p、q</code>同步往尾部移动，当<code>q</code>到达尾节点时，<code>p</code>后的节点即我们需要删除的目标节点。将p内节点的地址指向下下个节点，删除目标节点，任务完成。</p><h4 id="2-2-难点分析"><a href="#2-2-难点分析" class="headerlink" title="2.2 难点分析"></a>2.2 难点分析</h4><p>函数传进来的参数和传出去的值都是头结点，在删除节点时，有一个问题需要考虑，怎么保证下下个节点是存在的，如果恰好要删除的就是头节点，是否在程序中考虑到了？其实我刚开始也没考虑，就把示例传进去有正确结果返回高兴的屁颠屁颠以为自己做完了，但上传上去之后被特殊情况搞得晕头转向，仔细分析了很长时间才把<code>head、p、q</code>之间的关系理清楚。</p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> head:</span><br><span class="line">        p=head</span><br><span class="line">        q=head</span><br><span class="line">        <span class="comment"># 构建窗口，保证p、q指针之间间隔n个节点</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> q != <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment">#当循环结束，如果q=None，则说明需要删除的是头结点。</span></span><br><span class="line">            q = q.next</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> q != <span class="keyword">None</span>:<span class="comment">#需要删除的节点不是头结点，p、q正常往链表尾部滑动</span></span><br><span class="line">            <span class="keyword">while</span> q.next != <span class="keyword">None</span> : </span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line">        <span class="keyword">if</span> q == <span class="keyword">None</span> : <span class="comment">#要删除头节点</span></span><br><span class="line">           head = p.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = p.next.next <span class="comment">#正常情况 删除p后面的节点</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>O(N)                              <em>N为链表的节点个数</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;删除链表的指定节点&quot;&gt;&lt;a href=&quot;#删除链表的指定节点&quot; class=&quot;headerlink&quot; title=&quot;删除链表的指定节点&quot;&gt;&lt;/a&gt;删除链表的指定节点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：中等         思路：窗口法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;给定一个链表，删除链表的倒数第&lt;code&gt;n&lt;/code&gt;个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.&lt;/p&gt;
&lt;p&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：给定的n保证是有效的。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://izhen.tech/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="窗口法" scheme="http://izhen.tech/tags/%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>18题四个数的求和</title>
    <link href="http://izhen.tech/2019/02/18/18%E9%A2%98%E5%9B%9B%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C/"/>
    <id>http://izhen.tech/2019/02/18/18题四个数的和/</id>
    <published>2019-02-18T06:41:43.000Z</published>
    <updated>2019-03-01T09:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四个数的和"><a href="#四个数的和" class="headerlink" title="四个数的和"></a>四个数的和</h2><blockquote><p>难度：中等         思路：头尾逼近法</p></blockquote><h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个包含<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>，判断nums中是否存在四个元素a，b，c，和d，使得<code>a+b+c+d</code>的值与target相等？找出所有满足条件且不重复的四元组。</p><p>注意：答案中不可以包含重复的四元组。</p><a id="more"></a><p>示例：</p><blockquote><p>给定数组nums=[1, 0, -1, 0, -2, 2], 和target=0。</p><p>满足要求的四元组集合为：</p><p>[[-1 ,0, 0, 1],</p><p>[-2, -1, 1, 2],</p><p>[-2 ,0, 0, 2]]</p></blockquote><h3 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h3><p>在LeetCode的题目顺序有一个由浅入深的过渡，这题的解决方法完全可以参照三个数的求和问题。让我们来回顾一个三个数的求和问题，三个数的求和与四个数的求和表面上是一模一样的，无非是把三个数替换为四个数，所以在解决方式上内核机制也是相同的。</p><h4 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1 排序"></a>2.1 排序</h4><p>数的求和问题，最简单粗暴的方法就是把给定的数组for循环遍历几次，找到所有符合要求的数，但是因为时间开销过大，提交的时候不被通过，所以只能找其他的渠道。第一步，将所给的数按照从小到大排序，Python有内置的排序函数，这里就直接调用了。</p><h4 id="2-2-开始遍历"><a href="#2-2-开始遍历" class="headerlink" title="2.2 开始遍历"></a>2.2 开始遍历</h4><p>在多个数求和问题中，使用的方法为两头法，具体实现方法如下。首先固定第一个数，从数组的头部开始，求出目标数target与第一个数的差值diff；然后固定第二个数，求出之前的差值diff与当前数的差值作为新目标goal；然后使用头尾法，如果头尾的和小于goal，则头往后移，如果头尾的和大于goal，则尾往前移（经过排序后，尾部的数大头部的数小），如果头尾的和正好等于goal，那么我们找到了目标数，把四个数存到结果中，同时往中间移动头尾的坐标，头尾位置下标相等时此次遍历结束；然后依次移动前两个固定的数。</p><h4 id="2-3-难点分析"><a href="#2-3-难点分析" class="headerlink" title="2.3 难点分析"></a>2.3 难点分析</h4><p>这题确定了算法，还是有很多细节需要推敲，而这些细节有些时候比算法本身更花时间。在题目描述中，它特地提出让我们注意解决重复元素的问题，解决重复问题有两个思路：一是处理返回的数组，将其中重复的元素去掉；二是从源头上解决问题，在生成结果数组时，一旦发现重复就不再添加入返回数组。这题真正的难点就在这里了，怎么样才能最有效的去除重复元素呢？这里只提供一个巧妙的思路，重复的元素从何而来，归根结底是因为数组中本身就有重复的元素，在求和的时候，当我们移动到下一个元素的时候，检测当前元素与上一个元素是否相等，这里为什么是与前一个元素作比较而不是与后一个元素作比较，这是有原因的，如果与后一个元素作比较的话，那么就会漏掉一种情况，这两个数相等但是他们的和就是我们想找的，如果与后一个元素作比较的话这个数还没有参与计算就会被跳过。结果会错误。（注意，当我们访问一个元素的时候要确保这个元素存在否则就会报错），如果相等就跳过此次循环。（<strong>需要确保每个不重复元素都被访问到</strong>）</p><h4 id="2-4-细节"><a href="#2-4-细节" class="headerlink" title="2.4 细节"></a>2.4 细节</h4><p>首先要对输入的数组进行长度判断，避免输入空数组时后续进行不存在位置的的访问导致程序崩溃；其次是重复元素的问题，在元素移动过程中，为了不产生重复的四个数组合，固定的第一个数往后移动时，需要考虑当前数与上一个数是否相等，如果相等，则使用<code>continue</code>语句跳过此次循环。固定的第一个数也存在一模一样的问题。其次是首尾移动时，当检测到首尾之和相等时，头部和尾部的位置都往中间移，这时头尾分别与后一个数作比较，如果相等的话，头尾坐标继续往中间靠。（这里检测到头尾之和与目标相等时，不存在一个数还没用到就被丢弃，所以可以与后一个数作比较）</p><h3 id="三、代码分析"><a href="#三、代码分析" class="headerlink" title="三、代码分析"></a>三、代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    res=[]</span><br><span class="line">    nums=sorted(nums) <span class="comment">#排序</span></span><br><span class="line">    length=len(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length<span class="number">-3</span>):</span><br><span class="line">        diff=target-nums[i]</span><br><span class="line">        <span class="keyword">if</span> i &gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i]: <span class="comment">#防止重复</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length<span class="number">-2</span>):</span><br><span class="line">            goal=diff-nums[j]</span><br><span class="line">            front=j+<span class="number">1</span></span><br><span class="line">            back=length<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j<span class="number">-1</span>] == nums[j]:<span class="comment">#防止重复</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> front&lt;back:</span><br><span class="line">                the_sum=nums[front]+nums[back]</span><br><span class="line">                <span class="keyword">if</span> the_sum &lt; goal:</span><br><span class="line">                    front += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> the_sum &gt; goal:</span><br><span class="line">                    back -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> the_sum == goal:                        </span><br><span class="line">                    res.append([nums[i], nums[j], nums[front],nums[back]])</span><br><span class="line">                    <span class="keyword">while</span> front &lt;back <span class="keyword">and</span> nums[front] == nums[front+<span class="number">1</span>]:<span class="comment">#防止重复</span></span><br><span class="line">                        front+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> front &lt; back <span class="keyword">and</span> nums[back]==nums[back<span class="number">-1</span>]:<span class="comment">#防止重复</span></span><br><span class="line">                        back -=<span class="number">1</span></span><br><span class="line">                    front += <span class="number">1</span></span><br><span class="line">                    back -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>耗时还是非常多的，排序+O(N^3^)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四个数的和&quot;&gt;&lt;a href=&quot;#四个数的和&quot; class=&quot;headerlink&quot; title=&quot;四个数的和&quot;&gt;&lt;/a&gt;四个数的和&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：中等         思路：头尾逼近法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;给定一个包含&lt;code&gt;n&lt;/code&gt;个整数的数组&lt;code&gt;nums&lt;/code&gt;和一个目标值&lt;code&gt;target&lt;/code&gt;，判断nums中是否存在四个元素a，b，c，和d，使得&lt;code&gt;a+b+c+d&lt;/code&gt;的值与target相等？找出所有满足条件且不重复的四元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的四元组。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="求和" scheme="http://izhen.tech/tags/%E6%B1%82%E5%92%8C/"/>
    
      <category term="数组" scheme="http://izhen.tech/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>17题电话号码的字母组合</title>
    <link href="http://izhen.tech/2019/02/18/17%E9%A2%98%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://izhen.tech/2019/02/18/17题电话号码的字母组合/</id>
    <published>2019-02-18T03:51:43.000Z</published>
    <updated>2019-03-01T09:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><blockquote><p>难度：中等         思路：递归</p></blockquote><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个仅包含数字<code>2-9</code>的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意<code>1</code>不对应任何字母。</p><a id="more"></a><p><img src="/2019/02/18/17题电话号码的字母组合/1550226768193.png" alt="1550226768193"></p><p>示例：</p><p>输入：“23”</p><p>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p><h3 id="二、解题过程"><a href="#二、解题过程" class="headerlink" title="二、解题过程"></a>二、解题过程</h3><p>拿到这个题目，分析我们要解决的问题，题目给出了数字到字母的映射，故首先要把映射关系一一对应出来，在Python中很容易想到字典，把映射关系先存起来，唯一值得推敲的是这里的值的类型是存成字符串<code>&quot;abc&quot;</code>还是数组<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>呢？看到电话按键我们很容易想到字符串，但研究我们最终的输出结果类型，存为数组类型更方便后边的计算，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_map = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>], </span><br><span class="line">            <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>], <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>], </span><br><span class="line">            <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>], <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>], <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br></pre></td></tr></table></figure><p>第二步来到了怎么解决这个题目，这个题目看起来很简单，实际上也很简单但就需要那么灵光一现，首先把它的结构图画出来，本质上是一个全组合问题，通过for循环遍历给出的数字所对应的字母，然后内部嵌套for循环遍历下一个数字对应的字母，就这样层层嵌套，唯一的难点是我们无法提前预知需要嵌套多少层for循环。</p><p>灵光乍现了，递归函数能够很好的解决这种循环问题。通过认真分析，发现这题用递归是最棒的方法。首先来复习一下递归：</p><p>递归将问题分解为越来越小的子问题，直到问题的规模小到可以被直接解决。<strong>每个递归函数都有两个部分：基线条件和递归条件 </strong>。递归条件指的是函数调用自己，而基线条件是指函数不再调用自己，从而避免无限循环。</p><p>如果你还对递归算法有疑问的话，试着写一个关于某个数阶乘的递归算法，<code>fact(n) return n*(n-1)*(n-2)...</code>规定<code>0！=1</code>，最合适的基线条件什么呢？</p><p>分析此题，基线条件可以是待访问的数字个数为1时，返回这个键的映射值；递归条件为访问当前访问数字的第一个数字，然后for循环遍历这个数字对应的字母，在for循环内部，将数字的第一位去掉然后调用函数本身。然后for循环遍历返回值。</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        dict_map = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>], </span><br><span class="line">                    <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>], <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>], </span><br><span class="line">                    <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>], <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">                    <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>], <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(digits) :           </span><br><span class="line">            <span class="keyword">if</span> len(digits) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> dict_map[digits[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = dict_map[digits[<span class="number">0</span>]]</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> first:</span><br><span class="line">                    second = self.letterCombinations(digits[<span class="number">1</span>:])</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> second:</span><br><span class="line">                        t = x + y</span><br><span class="line">                        res.append(t)</span><br><span class="line">                <span class="keyword">return</span> res </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;电话号码的字母组合&quot;&gt;&lt;a href=&quot;#电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;电话号码的字母组合&quot;&gt;&lt;/a&gt;电话号码的字母组合&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;难度：中等         思路：递归&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h3&gt;&lt;p&gt;给定一个仅包含数字&lt;code&gt;2-9&lt;/code&gt;的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意&lt;code&gt;1&lt;/code&gt;不对应任何字母。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://izhen.tech/categories/LeetCode/"/>
    
    
      <category term="算法" scheme="http://izhen.tech/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://izhen.tech/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>树莓派控制红外遥控</title>
    <link href="http://izhen.tech/2019/01/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/"/>
    <id>http://izhen.tech/2019/01/23/树莓派控制红外遥控/</id>
    <published>2019-01-23T08:49:56.000Z</published>
    <updated>2019-01-23T08:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树莓派控制红外遥控"><a href="#树莓派控制红外遥控" class="headerlink" title="树莓派控制红外遥控"></a>树莓派控制红外遥控</h3><blockquote><p><strong>写在前面</strong>：因项目需要，故在网上淘了一个红外遥控模块，在树莓派上学习一下红外遥控。</p></blockquote><h3 id="一、红外遥控及接线"><a href="#一、红外遥控及接线" class="headerlink" title="一、红外遥控及接线"></a>一、红外遥控及接线</h3><p>​    38K通用红外遥控器，采用NEC编码格式，传输距离大于八米，比较适合日常开发，使用方便。</p><p>​    红外接收模块引脚说明：S为OUT引脚，中间为VCC，-为GND。根据模块上的标识来接。</p><p>​    插到树莓派上，S接树莓派的12引脚（物理引脚编码），其BCM编码为18；VCC接3.3V；GND接树莓派任意GND引脚即可。模块实拍如下图所示：<br><a id="more"></a><br><img src="/2019/01/23/树莓派控制红外遥控/1548142845457.png" alt="1548142845457"></p><h3 id="二、软件配置"><a href="#二、软件配置" class="headerlink" title="二、软件配置"></a>二、软件配置</h3><h4 id="2-1-安装lirc，修改配置文件"><a href="#2-1-安装lirc，修改配置文件" class="headerlink" title="2.1 安装lirc，修改配置文件"></a>2.1 安装lirc，修改配置文件</h4><p>​    LIRC（Linux Infrared remote control）是一个Linux系统下开源的软件包，用来从远程通用红外设备上接收和发送红外信号。可以解码和发送红外信号。</p><p>​    通过SSH连接树莓派，安装lirc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lirc</span><br></pre></td></tr></table></figure><p>​    因为lirc版本更新的原因，不同的版本修改的配置文件不同，输入<code>lircd -v</code>查看lirc的版本，我是0.9.4.c，修改<code>/etc/lirc/lirc_options.conf</code>文件，用<code>vi</code>进入修改：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lircd]</span></span><br><span class="line"><span class="comment"># driver = devinput</span></span><br><span class="line"><span class="attr">driver</span>   = default</span><br></pre></td></tr></table></figure><h4 id="2-2-修改-boot-config-txt"><a href="#2-2-修改-boot-config-txt" class="headerlink" title="2.2 修改/boot/config.txt"></a>2.2 修改<code>/boot/config.txt</code></h4><p>​    用<code>vi</code>进入文件内部，找到<code>dtoverlay</code>并修改如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dtoverlay</span>=lirc-rpi,gpio_in_pin = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>​    这里18对应树莓派BCM编码的gpio接口。</p><h4 id="2-3-重新开启lirc"><a href="#2-3-重新开启lirc" class="headerlink" title="2.3 重新开启lirc"></a>2.3 重新开启lirc</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/lircd restart</span><br><span class="line">sudo modprobe lirc_rpi</span><br></pre></td></tr></table></figure><p>至此，<code>lirc</code>软件配置完成</p><h3 id="三、测试红外接收"><a href="#三、测试红外接收" class="headerlink" title="三、测试红外接收"></a>三、测试红外接收</h3><h4 id="3-1关闭红外接收功能"><a href="#3-1关闭红外接收功能" class="headerlink" title="3.1关闭红外接收功能"></a>3.1关闭红外接收功能</h4><p>命令行输入以下命令，关闭<code>lirc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> $(pidof lircd)</span><br></pre></td></tr></table></figure><h4 id="3-4-测试红外接收"><a href="#3-4-测试红外接收" class="headerlink" title="3.4 测试红外接收"></a>3.4 测试红外接收</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode2 -d/dev/lirc0</span><br></pre></td></tr></table></figure><p>用红外遥控器，对着接收器按下任意按键，屏幕会打印类似下面的内容，说明红外接收功能正常。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">space 562</span><br><span class="line">pulse 579</span><br><span class="line">space 1672</span><br><span class="line">pulse 577</span><br></pre></td></tr></table></figure><p>在这里我卡壳了，接收不到任何内容，反复检查了前面的步骤，确定无误后继续谷歌，找到了这篇博客<a href="http://www.eeboard.com/bbs/thread-6940-1-1.html" target="_blank" rel="noopener">^1</a>，之前输出随意找了一个IO口，但是都没有用，把OUT连接到GPIO pin12上，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg | grep -i lirc</span><br></pre></td></tr></table></figure><p>发现有内容了，怀疑是红外遥控的输出引脚有指定。</p><h4 id="3-5-红外编码录制"><a href="#3-5-红外编码录制" class="headerlink" title="3.5 红外编码录制"></a>3.5 红外编码录制</h4><p>首先查看有哪些按键名并记录，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo irrecord --list-namaspace</span><br></pre></td></tr></table></figure><p>我用的几个键名是：</p><table><thead><tr><th>按键</th><th>按键名</th></tr></thead><tbody><tr><td>1</td><td>KEY_1</td></tr><tr><td>2</td><td>KEY_2</td></tr><tr><td>3</td><td>KEY_3</td></tr><tr><td>4</td><td>KEY_4</td></tr><tr><td>5</td><td>KEY_5</td></tr><tr><td>6</td><td>KEY_6</td></tr><tr><td>7</td><td>KEY_7</td></tr><tr><td>8</td><td>KEY_8</td></tr><tr><td>9</td><td>KEY_9</td></tr><tr><td>0</td><td>KEY_0</td></tr><tr><td>*</td><td>KEY_STAR</td></tr><tr><td>#</td><td>KEY_PUND</td></tr><tr><td>↑</td><td>KEY_UP</td></tr><tr><td>↓</td><td>KEY_DOWN</td></tr><tr><td>←</td><td>KEY_LEFT</td></tr><tr><td>→</td><td>KEY_RIGHT</td></tr><tr><td>OK</td><td>KEY_OK</td></tr></tbody></table><p>执行红外线编码录制命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo irrecord -d /dev/lirc0 ~/lircd.conf</span><br></pre></td></tr></table></figure><p>刚开始需要输入文件名称，最终会根据此名称保存对应的文件名，我的文件名为<code>pi-key</code>，然后会有一堆英文提示出来，继续回车，会让你按按键，每个按键保证屏幕上输出一个<code>.</code>,一直按保证所有的按键都被按到，全部按过一遍之后就不停的按最后按的那个按键</p><p><img src="/2019/01/23/树莓派控制红外遥控/1548230657351.png" alt="1548230657351">然后就会弹出第二轮按键录入，这时也是不停按，要有耐心，循环按，使劲按，直到弹出需要你输入下一个按键的名字为止。如下：</p><p><img src="/2019/01/23/树莓派控制红外遥控/1548230697554.png" alt="1548230697554"></p><p>这时依次录入按键名字，然后按下对应的按键，输入按键名字不能输删除，如果输错了也不要紧，按回车重新输入即可。将所有的按键都录入，这一步就结束了。成功之后会在~/目录下生成<code>pi.lircd.conf</code>这个文件，把这个文件放到<code>/etc/lirc/lircd/lircd.conf.d/</code>这个目录里即可，命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ~/pi.lircd.conf /etc/lirc/lircd.conf.d/</span><br></pre></td></tr></table></figure><p>完成后重启树莓派。</p><h3 id="四、运行Python代码"><a href="#四、运行Python代码" class="headerlink" title="四、运行Python代码"></a>四、运行Python代码</h3><p>运行编写的Python代码，终端会显示按键的键值。</p><p>Python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Constants <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">PIN = <span class="number">18</span></span><br><span class="line">delay_time = <span class="number">0.00006</span></span><br><span class="line"></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line">GPIO.setup(PIN, GPIO.IN, GPIO.PUD_UP)</span><br><span class="line">print(<span class="string">"irm test start..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span><span class="params">(key_val)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(key_val==Keys.KEY_1):  </span><br><span class="line">        print(<span class="string">"Button KEY_1"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_2):  </span><br><span class="line">        print(<span class="string">"Button KEY_2"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_3):  </span><br><span class="line">        print(<span class="string">"Button KEY_3"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_4):  </span><br><span class="line">        print(<span class="string">"Button KEY_4"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_5):  </span><br><span class="line">        print(<span class="string">"Button KEY_5"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_6):  </span><br><span class="line">        print(<span class="string">"Button KEY_6"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_7):  </span><br><span class="line">        print(<span class="string">"Button KEY_7"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_8):  </span><br><span class="line">        print(<span class="string">"Button KEY_8"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_9):  </span><br><span class="line">        print(<span class="string">"Button KEY_9"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_0):  </span><br><span class="line">        print(<span class="string">"Button 0"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_STAR):  </span><br><span class="line">        print(<span class="string">"Button KEY_STAR"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_POUND):  </span><br><span class="line">        print(<span class="string">"Button KEY_POUND"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_UP):  </span><br><span class="line">        print(<span class="string">"Button KEY_UP"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_LEFT):  </span><br><span class="line">        print(<span class="string">"Button KEY_LEFT"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_OK):  </span><br><span class="line">        print(<span class="string">"Button KEY_OK"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_RIGHT):  </span><br><span class="line">        print(<span class="string">"Button KEY_RIGHT"</span>)  </span><br><span class="line">    <span class="keyword">elif</span>(key_val==Keys.KEY_DOWN):  </span><br><span class="line">        print(<span class="string">"Button KEY_DOWN"</span>)  </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> GPIO.input(PIN) == <span class="number">0</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> GPIO.input(PIN) ==<span class="number">0</span> <span class="keyword">and</span> count &lt;<span class="number">200</span>:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">                time.sleep(delay_time)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span> GPIO.input(PIN) == <span class="number">1</span> <span class="keyword">and</span> count &lt; <span class="number">80</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                time.sleep(delay_time)</span><br><span class="line">            </span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            data = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> GPIO.input(PIN) ==<span class="number">1</span> <span class="keyword">and</span> count &lt; <span class="number">15</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    time.sleeep(delay_time)</span><br><span class="line">                </span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> GPIO.input(PIN) == <span class="number">1</span> <span class="keyword">and</span> count &lt; <span class="number">40</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    time.sleep(delay_time)</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">8</span>:</span><br><span class="line">                    data[idx] |= <span class="number">1</span>&lt;&lt;cnt</span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">7</span>:</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    idx +=<span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[<span class="number">0</span>]+data[<span class="number">1</span>] == <span class="number">0xFF</span> <span class="keyword">and</span> data[<span class="number">2</span>]+data[<span class="number">3</span>] == <span class="number">0xFF</span> :</span><br><span class="line">                print(<span class="string">"Get the key: 0x%02x"</span>%data[<span class="number">2</span>])</span><br><span class="line">                exec_cmd(data[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    GPIO.cleanup();</span><br></pre></td></tr></table></figure><p>按下遥控按键，终端会显示接收到的按键的键值：</p><p><img src="/2019/01/23/树莓派控制红外遥控/1548232503540.png" alt="1548232503540"></p><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p>1、网址：<a href="https://iaiai.iteye.com/blog/2411532" target="_blank" rel="noopener">https://iaiai.iteye.com/blog/2411532</a></p><p>2、产品说明书：<strong><a href="https://pan.baidu.com/s/1E3tnY1Kzo_Sdkju7QzQylQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1E3tnY1Kzo_Sdkju7QzQylQ</a></strong> </p><p>3、网址：<a href="http://www.eeboard.com/bbs/thread-6940-1-1.html" target="_blank" rel="noopener">http://www.eeboard.com/bbs/thread-6940-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树莓派控制红外遥控&quot;&gt;&lt;a href=&quot;#树莓派控制红外遥控&quot; class=&quot;headerlink&quot; title=&quot;树莓派控制红外遥控&quot;&gt;&lt;/a&gt;树莓派控制红外遥控&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;：因项目需要，故在网上淘了一个红外遥控模块，在树莓派上学习一下红外遥控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、红外遥控及接线&quot;&gt;&lt;a href=&quot;#一、红外遥控及接线&quot; class=&quot;headerlink&quot; title=&quot;一、红外遥控及接线&quot;&gt;&lt;/a&gt;一、红外遥控及接线&lt;/h3&gt;&lt;p&gt;​    38K通用红外遥控器，采用NEC编码格式，传输距离大于八米，比较适合日常开发，使用方便。&lt;/p&gt;
&lt;p&gt;​    红外接收模块引脚说明：S为OUT引脚，中间为VCC，-为GND。根据模块上的标识来接。&lt;/p&gt;
&lt;p&gt;​    插到树莓派上，S接树莓派的12引脚（物理引脚编码），其BCM编码为18；VCC接3.3V；GND接树莓派任意GND引脚即可。模块实拍如下图所示：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="树莓派" scheme="http://izhen.tech/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="http://izhen.tech/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="红外遥控" scheme="http://izhen.tech/tags/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7/"/>
    
  </entry>
  
</feed>
