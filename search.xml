<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[24题一组数据交换相邻节点]]></title>
    <url>%2F2019%2F03%2F01%2F24%E9%A2%98%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[交换相邻节点 难度：中等 思路：递归 一、题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 二、问题分析链表中节点的交换是传统问题，两个指针解决问题，唯一要注意的是不能在交换过程中把链表给断开了，否则岂不是得不偿失？暴力法本可以解决一切，但是优雅的方法是递归，把相邻节点的交换搞定，然后递归把所有的节点串起来，简直是美滋滋啊。 三、代码分析12345678910111213141516171819class Solution: def swapPairs(self, head): # 防止只有一个节点或没有节点时报错 if head and head.next: p = head q = head.next head = q # 第一次交换不需要考虑与前面的连接 三步法连接 p.next = q.next q.next = p # 开始递归 p.next = self.swapPairs(p.next) else: if head: return head else: return None return head 复杂度分析 O(N)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
        <tag>交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23题合并k个有序的链表]]></title>
    <url>%2F2019%2F03%2F01%2F23%E9%A2%98%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并K个有序的链表 难度： hard模式 思路：优先级队列 一、题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 二、问题分析首先是hard模式，说明不能轻易的解决这个问题。认真思考了一个小时，觉得已经理清楚思路，然而苦于不知该如何实现自己的思路。试了几种方法，反而是原地打转，于是决定参考一下答案。答案实现了我的思路，原来使用了一种之前没有用过的数据结构，优先级队列(PrivirotyQueue),这一篇专栏简单介绍了优先级队列，对于理解这题，简直是正中靶心。 思路如下： 用三个指针指向k个链表的头部，比较指针中的值，将最小的值加入到结果中，然后指针后移，直到所有的指针为空。由于是列表，无法直接得到所有链表的头部，所以只能通过优先级队列来做。遍历列表，将头指针和头指针的val组成一个元组入队列，出队列时头指针的val作为评判其优先级的标准。注意事项，当队列中的元组优先级(即头指针的val)相同时，将会把指针这个对象作为比较优先级的评判标准，但是对象在python中是不能直接比较的，会引起代码崩溃，元组之间的元素用逗号隔开，不能有空格，否则代码也会崩溃。 三、代码分析123456789101112131415161718192021222324from queue import PriorityQueue as PQ# 导入优先级队列的包class Solution: def mergeKLists(self, lists): head = point = ListNode(0) pq = PQ() index = 0 for l in lists: if l: # 当列表的优先级相同(即val相等）时，由元祖中的第二个元素确定优先级， # 而链表是对象不能直接确定优先级，所以加入一个变化的下标作为优先级避免程序崩溃 pq.put((l.val,index,l)) index += 1 while not pq.empty(): val,index, node = pq.get() # 不能直接操作point，会导致链表的断裂 point.next = node point = point.next node = node.next if node != None: pq.put((node.val,index,node)) index += 1 return head.next 复杂度分析 O(N log k) :比较大小的时间花费将被减少到O(log k)，因为优先级队列的内部实现机制用到了堆，但是找到最小值的节点仅仅花费 O(1)， 在最终的链表中有K个节点。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>优先级队列，链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21题有序链表的合并]]></title>
    <url>%2F2019%2F02%2F22%2F21%E9%A2%98%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[LeetCode刷题之21题有序链表的合并 难度：easy 思路：硬算 一、题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 二、问题分析有序链表的合并是归并排序中的经典算法，这题采用常规思路即可解决问题，唯一要注意的点是当指针p、q中任一指针为空时后续应该如何操作。 三、代码分析1234567891011121314151617181920212223242526272829303132333435def mergeTwoLists(self, l1, l2,): p = l1 q = l2 head = None # p q均不为空 while p != None and q != None: if p.val &lt;= q.val : if head == None: head = p n = p p = p.next else: n.next = p n = n.next p = p.next else : if head == None: head = q n = q q = q.next else: n.next = q n = n.next q = q.next # p q中任一为空 将p指定为非空 直接将p后面的节点连在n的后面 if p == None and q !=None: p = q q = None if head == None: head = p n = p else: n.next = p return head 时间复杂度分析： O(M+N) M为l1链表的长度，N为l2链表的长度]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之20题有效的括号]]></title>
    <url>%2F2019%2F02%2F22%2F20%E9%A2%98%E6%8B%AC%E5%8F%B7%E7%9A%84%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[LeetCode刷题之20题有效的括号 难度：简单 思路：栈 一、题目描述给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例： 12输入: "&#123;[]&#125;"输出: true 二、问题分析这是一题难度为简单的题，但我仍旧很久没有思路，就是没有想到利用栈的特性，本题是一道经典的栈的特性的题目，想到栈，就成功了一大半。 三、 代码分析123456789101112131415161718192021222324def isValid(self, s): res = True stack = [] for element in s: if not stack: # 栈为空 stack.append(element) # 利用栈的先进后出的特点，判断列表的尾部即栈的头部的元素情况 elif stack[-1] == '(' and element == ')': stack.pop() # 出栈在栈的头部 elif stack[-1] == '[' and element == ']': stack.pop() elif stack[-1] == '&#123;' and element == '&#125;': stack.pop() else: stack.append(element) # 进栈也在栈的头部 # 判断栈是否为空，为空则说明括号是对称有效 if stack : res = False else : res = True return res 复杂度分析： O(N) N为字符串的长度]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19题删除链表的指定节点]]></title>
    <url>%2F2019%2F02%2F18%2F19%E9%A2%98%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0N%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[删除链表的指定节点 难度：中等 思路：窗口法 一、问题描述给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。 示例： 给定一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明：给定的n保证是有效的。 进阶：你能尝试一趟扫描实现吗？ 二、问题分析2.1 逻辑梳理本题和链表有关，链表是最基本的数据结构，链表中的元素可存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。链表的优势在于插入和删除元素，可以快速完成而不需要移动其他元素。链表由一个个节点组成，节点有两部分，节点的值和下一个节点的地址，尾节点的下一个节点的地址为空。在Python中即None，想要通过一趟扫描删除倒数第n个节点，最有效的方法就是窗口法，指针p，q之间间隔n个节点，然后指针p、q同步往尾部移动，当q到达尾节点时，p后的节点即我们需要删除的目标节点。将p内节点的地址指向下下个节点，删除目标节点，任务完成。 2.2 难点分析函数传进来的参数和传出去的值都是头结点，在删除节点时，有一个问题需要考虑，怎么保证下下个节点是存在的，如果恰好要删除的就是头节点，是否在程序中考虑到了？其实我刚开始也没考虑，就把示例传进去有正确结果返回高兴的屁颠屁颠以为自己做完了，但上传上去之后被特殊情况搞得晕头转向，仔细分析了很长时间才把head、p、q之间的关系理清楚。 三、代码分析12345678910111213141516171819def removeNthFromEnd(self, head, n): if head: p=head q=head # 构建窗口，保证p、q指针之间间隔n个节点 while n&gt;0 and q != None: #当循环结束，如果q=None，则说明需要删除的是头结点。 q = q.next n -= 1 if q != None:#需要删除的节点不是头结点，p、q正常往链表尾部滑动 while q.next != None : p = p.next q = q.next if q == None : #要删除头节点 head = p.next else: p.next = p.next.next #正常情况 删除p后面的节点 return head 复杂度分析： O(N) N为链表的节点个数]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>窗口法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18题四个数的求和]]></title>
    <url>%2F2019%2F02%2F18%2F18%E9%A2%98%E5%9B%9B%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[四个数的和 难度：中等 思路：头尾逼近法 一、问题描述给定一个包含n个整数的数组nums和一个目标值target，判断nums中是否存在四个元素a，b，c，和d，使得a+b+c+d的值与target相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例： 给定数组nums=[1, 0, -1, 0, -2, 2], 和target=0。 满足要求的四元组集合为： [[-1 ,0, 0, 1], [-2, -1, 1, 2], [-2 ,0, 0, 2]] 二、问题分析在LeetCode的题目顺序有一个由浅入深的过渡，这题的解决方法完全可以参照三个数的求和问题。让我们来回顾一个三个数的求和问题，三个数的求和与四个数的求和表面上是一模一样的，无非是把三个数替换为四个数，所以在解决方式上内核机制也是相同的。 2.1 排序数的求和问题，最简单粗暴的方法就是把给定的数组for循环遍历几次，找到所有符合要求的数，但是因为时间开销过大，提交的时候不被通过，所以只能找其他的渠道。第一步，将所给的数按照从小到大排序，Python有内置的排序函数，这里就直接调用了。 2.2 开始遍历在多个数求和问题中，使用的方法为两头法，具体实现方法如下。首先固定第一个数，从数组的头部开始，求出目标数target与第一个数的差值diff；然后固定第二个数，求出之前的差值diff与当前数的差值作为新目标goal；然后使用头尾法，如果头尾的和小于goal，则头往后移，如果头尾的和大于goal，则尾往前移（经过排序后，尾部的数大头部的数小），如果头尾的和正好等于goal，那么我们找到了目标数，把四个数存到结果中，同时往中间移动头尾的坐标，头尾位置下标相等时此次遍历结束；然后依次移动前两个固定的数。 2.3 难点分析这题确定了算法，还是有很多细节需要推敲，而这些细节有些时候比算法本身更花时间。在题目描述中，它特地提出让我们注意解决重复元素的问题，解决重复问题有两个思路：一是处理返回的数组，将其中重复的元素去掉；二是从源头上解决问题，在生成结果数组时，一旦发现重复就不再添加入返回数组。这题真正的难点就在这里了，怎么样才能最有效的去除重复元素呢？这里只提供一个巧妙的思路，重复的元素从何而来，归根结底是因为数组中本身就有重复的元素，在求和的时候，当我们移动到下一个元素的时候，检测当前元素与上一个元素是否相等，这里为什么是与前一个元素作比较而不是与后一个元素作比较，这是有原因的，如果与后一个元素作比较的话，那么就会漏掉一种情况，这两个数相等但是他们的和就是我们想找的，如果与后一个元素作比较的话这个数还没有参与计算就会被跳过。结果会错误。（注意，当我们访问一个元素的时候要确保这个元素存在否则就会报错），如果相等就跳过此次循环。（需要确保每个不重复元素都被访问到） 2.4 细节首先要对输入的数组进行长度判断，避免输入空数组时后续进行不存在位置的的访问导致程序崩溃；其次是重复元素的问题，在元素移动过程中，为了不产生重复的四个数组合，固定的第一个数往后移动时，需要考虑当前数与上一个数是否相等，如果相等，则使用continue语句跳过此次循环。固定的第一个数也存在一模一样的问题。其次是首尾移动时，当检测到首尾之和相等时，头部和尾部的位置都往中间移，这时头尾分别与后一个数作比较，如果相等的话，头尾坐标继续往中间靠。（这里检测到头尾之和与目标相等时，不存在一个数还没用到就被丢弃，所以可以与后一个数作比较） 三、代码分析1234567891011121314151617181920212223242526272829303132def fourSum(self, nums, target): res=[] nums=sorted(nums) #排序 length=len(nums) if length &lt; 4: return res for i in range(0, length-3): diff=target-nums[i] if i &gt;0 and nums[i-1] == nums[i]: #防止重复 continue for j in range(i+1, length-2): goal=diff-nums[j] front=j+1 back=length-1 if j &gt;i+1 and nums[j-1] == nums[j]:#防止重复 continue while front&lt;back: the_sum=nums[front]+nums[back] if the_sum &lt; goal: front += 1 if the_sum &gt; goal: back -= 1 if the_sum == goal: res.append([nums[i], nums[j], nums[front],nums[back]]) while front &lt;back and nums[front] == nums[front+1]:#防止重复 front+=1 while front &lt; back and nums[back]==nums[back-1]:#防止重复 back -=1 front += 1 back -= 1 return res 复杂度分析： 耗时还是非常多的，排序+O(N^3^)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>求和</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17题电话号码的字母组合]]></title>
    <url>%2F2019%2F02%2F18%2F17%E9%A2%98%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[电话号码的字母组合 难度：中等 思路：递归 一、题目描述给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意1不对应任何字母。 示例： 输入：“23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”] 二、解题过程拿到这个题目，分析我们要解决的问题，题目给出了数字到字母的映射，故首先要把映射关系一一对应出来，在Python中很容易想到字典，把映射关系先存起来，唯一值得推敲的是这里的值的类型是存成字符串&quot;abc&quot;还是数组[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]呢？看到电话按键我们很容易想到字符串，但研究我们最终的输出结果类型，存为数组类型更方便后边的计算，如下： 1234dict_map = &#123;'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']&#125; 第二步来到了怎么解决这个题目，这个题目看起来很简单，实际上也很简单但就需要那么灵光一现，首先把它的结构图画出来，本质上是一个全组合问题，通过for循环遍历给出的数字所对应的字母，然后内部嵌套for循环遍历下一个数字对应的字母，就这样层层嵌套，唯一的难点是我们无法提前预知需要嵌套多少层for循环。 灵光乍现了，递归函数能够很好的解决这种循环问题。通过认真分析，发现这题用递归是最棒的方法。首先来复习一下递归： 递归将问题分解为越来越小的子问题，直到问题的规模小到可以被直接解决。每个递归函数都有两个部分：基线条件和递归条件 。递归条件指的是函数调用自己，而基线条件是指函数不再调用自己，从而避免无限循环。 如果你还对递归算法有疑问的话，试着写一个关于某个数阶乘的递归算法，fact(n) return n*(n-1)*(n-2)...规定0！=1，最合适的基线条件什么呢？ 分析此题，基线条件可以是待访问的数字个数为1时，返回这个键的映射值；递归条件为访问当前访问数字的第一个数字，然后for循环遍历这个数字对应的字母，在for循环内部，将数字的第一位去掉然后调用函数本身。然后for循环遍历返回值。 完整代码如下： 12345678910111213141516171819class Solution: def letterCombinations(self, digits): dict_map = &#123;'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']&#125; res = [] if len(digits) : if len(digits) == 1: return dict_map[digits[0]] else: first = dict_map[digits[0]] for x in first: second = self.letterCombinations(digits[1:]) for y in second: t = x + y res.append(t) return res return res]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派控制红外遥控]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[树莓派控制红外遥控 写在前面：因项目需要，故在网上淘了一个红外遥控模块，在树莓派上学习一下红外遥控。 一、红外遥控及接线​ 38K通用红外遥控器，采用NEC编码格式，传输距离大于八米，比较适合日常开发，使用方便。 ​ 红外接收模块引脚说明：S为OUT引脚，中间为VCC，-为GND。根据模块上的标识来接。 ​ 插到树莓派上，S接树莓派的12引脚（物理引脚编码），其BCM编码为18；VCC接3.3V；GND接树莓派任意GND引脚即可。模块实拍如下图所示： 二、软件配置2.1 安装lirc，修改配置文件​ LIRC（Linux Infrared remote control）是一个Linux系统下开源的软件包，用来从远程通用红外设备上接收和发送红外信号。可以解码和发送红外信号。 ​ 通过SSH连接树莓派，安装lirc： 1sudo apt-get install lirc ​ 因为lirc版本更新的原因，不同的版本修改的配置文件不同，输入lircd -v查看lirc的版本，我是0.9.4.c，修改/etc/lirc/lirc_options.conf文件，用vi进入修改： 123[lircd]# driver = devinputdriver = default 2.2 修改/boot/config.txt​ 用vi进入文件内部，找到dtoverlay并修改如下： 1dtoverlay=lirc-rpi,gpio_in_pin = 18 ​ 这里18对应树莓派BCM编码的gpio接口。 2.3 重新开启lirc12sudo /etc/init.d/lircd restartsudo modprobe lirc_rpi 至此，lirc软件配置完成 三、测试红外接收3.1关闭红外接收功能命令行输入以下命令，关闭lirc： 1sudo kill $(pidof lircd) 3.4 测试红外接收1mode2 -d/dev/lirc0 用红外遥控器，对着接收器按下任意按键，屏幕会打印类似下面的内容，说明红外接收功能正常。 1234space 562pulse 579space 1672pulse 577 在这里我卡壳了，接收不到任何内容，反复检查了前面的步骤，确定无误后继续谷歌，找到了这篇博客^1，之前输出随意找了一个IO口，但是都没有用，把OUT连接到GPIO pin12上，然后执行 1sudo dmesg | grep -i lirc 发现有内容了，怀疑是红外遥控的输出引脚有指定。 3.5 红外编码录制首先查看有哪些按键名并记录，输入： 1sudo irrecord --list-namaspace 我用的几个键名是： 按键 按键名 1 KEY_1 2 KEY_2 3 KEY_3 4 KEY_4 5 KEY_5 6 KEY_6 7 KEY_7 8 KEY_8 9 KEY_9 0 KEY_0 * KEY_STAR # KEY_PUND ↑ KEY_UP ↓ KEY_DOWN ← KEY_LEFT → KEY_RIGHT OK KEY_OK 执行红外线编码录制命令： 1sudo irrecord -d /dev/lirc0 ~/lircd.conf 刚开始需要输入文件名称，最终会根据此名称保存对应的文件名，我的文件名为pi-key，然后会有一堆英文提示出来，继续回车，会让你按按键，每个按键保证屏幕上输出一个.,一直按保证所有的按键都被按到，全部按过一遍之后就不停的按最后按的那个按键 然后就会弹出第二轮按键录入，这时也是不停按，要有耐心，循环按，使劲按，直到弹出需要你输入下一个按键的名字为止。如下： 这时依次录入按键名字，然后按下对应的按键，输入按键名字不能输删除，如果输错了也不要紧，按回车重新输入即可。将所有的按键都录入，这一步就结束了。成功之后会在~/目录下生成pi.lircd.conf这个文件，把这个文件放到/etc/lirc/lircd/lircd.conf.d/这个目录里即可，命令行输入： 1sudo cp ~/pi.lircd.conf /etc/lirc/lircd.conf.d/ 完成后重启树莓派。 四、运行Python代码运行编写的Python代码，终端会显示按键的键值。 Python代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python#-*-coding:utf-8-*-import RPi.GPIO as GPIOimport timefrom Constants import KeysPIN = 18delay_time = 0.00006GPIO.setmode(GPIO.BCM)GPIO.setup(PIN, GPIO.IN, GPIO.PUD_UP)print("irm test start...")def exec_cmd(key_val): if(key_val==Keys.KEY_1): print("Button KEY_1") elif(key_val==Keys.KEY_2): print("Button KEY_2") elif(key_val==Keys.KEY_3): print("Button KEY_3") elif(key_val==Keys.KEY_4): print("Button KEY_4") elif(key_val==Keys.KEY_5): print("Button KEY_5") elif(key_val==Keys.KEY_6): print("Button KEY_6") elif(key_val==Keys.KEY_7): print("Button KEY_7") elif(key_val==Keys.KEY_8): print("Button KEY_8") elif(key_val==Keys.KEY_9): print("Button KEY_9") elif(key_val==Keys.KEY_0): print("Button 0") elif(key_val==Keys.KEY_STAR): print("Button KEY_STAR") elif(key_val==Keys.KEY_POUND): print("Button KEY_POUND") elif(key_val==Keys.KEY_UP): print("Button KEY_UP") elif(key_val==Keys.KEY_LEFT): print("Button KEY_LEFT") elif(key_val==Keys.KEY_OK): print("Button KEY_OK") elif(key_val==Keys.KEY_RIGHT): print("Button KEY_RIGHT") elif(key_val==Keys.KEY_DOWN): print("Button KEY_DOWN") try: while True: if GPIO.input(PIN) == 0: count = 0 while GPIO.input(PIN) ==0 and count &lt;200: count +=1 time.sleep(delay_time) while GPIO.input(PIN) == 1 and count &lt; 80: count += 1 time.sleep(delay_time) idx = 0 cnt = 0 data = [0, 0, 0, 0] for i in range(0, 32): count = 0 while GPIO.input(PIN) ==1 and count &lt; 15: count += 1 time.sleeep(delay_time) count = 0 while GPIO.input(PIN) == 1 and count &lt; 40: count += 1 time.sleep(delay_time) if count &gt; 8: data[idx] |= 1&lt;&lt;cnt if cnt == 7: cnt = 0; idx +=1; else: cnt += 1 if data[0]+data[1] == 0xFF and data[2]+data[3] == 0xFF : print("Get the key: 0x%02x"%data[2]) exec_cmd(data[2])except KeyboardInterrupt: GPIO.cleanup(); 按下遥控按键，终端会显示接收到的按键的键值： 五、参考资料1、网址：https://iaiai.iteye.com/blog/2411532 2、产品说明书：https://pan.baidu.com/s/1E3tnY1Kzo_Sdkju7QzQylQ 3、网址：http://www.eeboard.com/bbs/thread-6940-1-1.html]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>红外遥控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT博客美化]]></title>
    <url>%2F2019%2F01%2F20%2FHexo%E4%B9%8BNexT%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Hexo之NexT博客美化 写在前面：默认的hexo界面看起来还是太简陋了，可以给Hexo换一个主题，这里推荐NexT，这是一个比较成熟的主题，使用的人也是最多的，优化，配置扩展都集成了，使用起来比较简单。然后再对功能界面做一些扩展，博客重质量，界面做的干净、清爽就行。本文详细介绍了博客美化的步骤。 一、安装NexT主题在命令行输入 1git clone https://github.com/theme-next/hexo-theme-next themes/next 下载主题。打开根目录下的_config.yml为博客的站点配置文件，主题配置文件在./themes/_config.yml。本文的整个配置基本是在修改这两个配置文件，所以你需要区分清楚。在站点配置文件./config.yml查找theme并修改： 12## Themes: https://hexo.io/themes/theme: next 这样就启用了主题next，可以输入hexo s查看效果。注意，有时候通过hexo s预览时，你会发现自己所做的修改并没有生效，这时不要着急，命令行输入hexo clean清理下database文件夹和public文件夹即可。 二、博客设置需要先对博客基本信息做一些设置，注意，设置时冒号后面都要有一个空格，这是yml语法格式。否则会报错或修改不生效。 2.1、设置语言在站点配置文件./_config.yml中，将language设置成所需要的语言。例如简体中文，配置如下： 1language: zh-CN 2.2、基本信息配置在站点配置文件./_config.yml的开头，填上自己博客的相应信息： 12345title: #标题subtitle: #子主页标题 description: #描述keywords: #关键字author: #作者zhen 2.3、设置主题的SchemeNext自带了几种外观，在主题配置文件./themes/next/_config.yml里找到schemes，可以自行选择布局，根据个人喜好，把前面的注释符#去掉即可： 12345# Schemes# scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 2.4、菜单栏设置在网站首页有归档等菜单，在主题配置文件./themes/next/_config.yml里找到menu，把需要的菜单取消注释。另外也可以自己添加菜单栏，||后面是font awesome图标栏，如下： 123456789menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 2.5、创建页面设置完菜单但是没有相关页面的话点击进去就会显示错误。在命令行输入 123hexo new page tagshexo new page categorieshexo new page about 然后在./source/_posts文件夹下面会生成对应的文件夹，打开将页面的type设置为相应的内容。例： 123456---title: 这里是所有分类的汇总categories: 分类名 type: "categories"date: 2019-01-17 15:29:31--- 2.6、文章显示设置默认首页的文章会显示全文，在发表文章的内容中加上&lt;!--more--&gt; 这样首页中文章会显示到你插入这句话的前面，点击阅读全文才会显示整篇文章。 2.7、使用RSS在命令行中输入: 1npm install --save hexo-generator-feed 安装插件，然后在主题配置文件./themes/next/_config.yml中找到rss并修改： 1rss: /atom.xml 2.8、设置博客favicon图标在./themes/next/source/images目录下放置图标，和默认的图标类似，然后在主题配置文件./themes/next/_config.yml找到favicon并修改： 1234567favicon: small: /images/favicon-16x16-next.ico medium: /images/favicon-32x32-next.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 2.9、侧边栏社交链接在主题配置文件./themes/next/_config.yml找到social把需要的内容取消注释，填好你的链接就可以。||后面的是图标名称，和菜单一样，也是使用的Font Awesome`图标。 123456789101112social: GitHub: https://github.com/zhengirl || github #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 2.10、设置背景动画在主题配置文件中，找到canvas_nest，改为true： 1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 2.11、修改文章底部的#号标签打开./themes/next/layout/_macro/post.swig文件中，搜索rel=&quot;tag&quot;&gt;#,将#替换为Font Awesome图标： 1rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; 2.12、搜索服务在命令行输入： 1npm install hexo-generator-searchdb --save 安装hexo-generator-searchdb插件，然后在站点配置文件./_config.yml添加以下代码： 123456# searchsearch: path: search.xml field: post format: html limit: 10000 然后在主题配置文件./themes/next/_config.yml中找到local_search改为true即可： 12local_search: enable: true 2.13、代码高亮在站点配置文件./_config.yml内找到highlight，并设置如下： 123456highlight: enable: true line_number: true #代码自动高亮 auto_detect: true tab_replace: 然后在主题配置文件./themes/next/_config.yml中找到highlight_theme，设置成你喜欢的代码高亮主题： 1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 2.14、头像圆形和旋转将头像显示成圆形，鼠标放上去有旋转效果，在.\themes\next\source\css\_common\components\sidebar\sidebar-author.styl文件将里面的内容替换为： 12345678910111213141516171819202122232425262728293031323334.site-author-image &#123; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125;.site-author-image:hover &#123; background-color: #e6be93; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 2.15、添加文章字数和阅读时长统计功能首先需要在命令行输入： 1npm install hexo-symbols-count-time --save 安装统计插件，然后在站点配置文件./_config.yml末尾添加如下使能统计功能的代码： 123456# reading timesymbols_count_time: symbols: true time: true total_symbols: true total_time: true 2.16、保留文章本身的编号我们在写博客的时候，会自己给文章编号，但next主题默认的也有编号，这样多个编号就比较奇怪，所以把默认的编号取消，在主题配置文件查找toc，修改如下： 1234toc: enable: true # Automatically add list number to toc. number: false 2.17、自定义博客Next中留出给使用者自我设计的空间，在/themes/next/source/css/_custom/cutom.styl文件中可以自行添加一些小样式让博客有所不同： 123456789//文章阴影与边缘强化.post &#123; margin-top: 0px; margin-bottom: 0px; border-radius: 16px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.70); -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.70);&#125; 三、在文章中显示图片首先在站点配置文件中将post_asset_folder后面修改为true，在建立一篇新的博客时，Hexo会自动建立一个与文章同名的文件夹，这样一来，就可以把图片存储在这个文件夹中方便调用。 其次本人习惯于在typora中将markdown文件编辑好之后直接复制到hexo中，所以需要对typora的设置做一些更改，打开偏好设置，选择将图片复制到指定文件夹中，这样在typora中也有指定的与文章同名的文件夹，所以将文章和文件夹都复制到Hexo中即可。 在命令行输入 1npm install https://github.com/CodeFalling/hexo-asset-image --save 安装插件，等待一段时间。输入hexo s在本地预览网站图片就可以显示啦！ 四、致谢在搭建博客的过程中，遇到了一些问题，参考了很多大佬的解决方案，感谢他们的分享。本文只是将自己搭建博客的过程复述了一遍，希望对后来者有所帮助。 推荐在配置的时看官方文档：http://theme-next.iissnan.com/third-party-services.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>美化设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2019%2F01%2F20%2FHexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Hexo+GitHub搭建个人博客author：刘真真 写在前面：去年三月份时候阿里云做活动就申请了一个域名，但是一直觉得搭建网站是一个比较麻烦的时候，就搁置了很久，在男朋友的鼓励下，遂决定好好捯饬一下自己的网站拿来写博客，开始一直担心自己做不出比较好的效果，后面渐渐将这种想法搁置，网上有非常多hexo的爱好者将自己的过程分享出来，基本上踩得坑都是前人遇到的，前人栽树后人乘凉，我也将搭建博客中一些关键性的步骤总结一下，以防后人跳坑。本人没有接触过前端知识，全凭谷歌和百度，所以有搭建个人网站想法的同学尽管去做，开始了第一步，后面的就不是问题了。 一、前期准备1.1、安装Node.js在Node.js官网下载对应平台的安装程序。在Windows上安装时需选择全部组建，勾选Add to Path,打开命令行安装成功可以看到 1.2、安装git在Git官网上下载Windows的安装程序。安装完成后，在开始菜单里找到”Git bsah Here”,弹出一个类似命令行的窗口，说明Git安装成功！ 同时配置电脑的环境变量，或者在安装的时候选择use Git from the Windows Command Prompt,即可在命令行中调用git。 1.3、Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，以免后面产生不必要的麻烦。 1.4、安装hexo在电脑的任何位置建一个文件夹，我在E盘建了一个与工程同名的zhengirl.github.io文件夹，然后通过命令行进入该文件夹： 输入npm install hexo -g,开始安装hexo，输入hexo -v,检查hexo是否安装成功。 输入hexo init,初始化文件夹。经过漫长的等待，可以看到Start blogging with Hexo！。 输入npm install，安装所需要的组件。 二、本地网页的搭建2.1、体验hexo在安装好前面需要的一系列包后，输入hexo g，首次体验Hexo。 输入hexo s，开启服务器，访问该网址，正式体验Hexo。 2.2、将Hexo与github page联系起来首先需要设置Git的user name和email（如果是第一次使用的话）。打开命令行 12$ git config --golbal user.name. &quot;author&quot; #将用户名设为author$ git config --global user.email &quot;author@corpmail.com&quot; #将用户邮箱设为author@corpmail.com 添加SSH，详情见这篇博客,输入ssh -T gi@github.com,测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了。 2.3、配置Deployment用VScode打开zhengirl.git.com.io,即整个工程，找到站点配置文件_config.yml，查找repo并修改，在文件末尾： 1234deploy: type: git repository: git@github.com:zhengirl/zhengirl.github.io.git branch: master 2.4、新建博客在命令行执行命令：hexo new post “博客名” 此时在/source/_posts下可以看到已经创建的文件 但这里则多生成了一个博客名的文件夹，至于为什么会生成这个文件夹以及它的用途，我们在下篇文章详解。 2.5、部署文章在生成以及部署文章之前需要安装一个扩展，npm install hexo-develoyer-git --save，编辑好文章后输入hexo d -g，生成和部署网站。 部署成功后访问网址：http://用户名.github.io,将看到部署成功的整个网站。 至此为止，最基本的hexo+github搭建个人博客基本完成，但是我们的博客还是太简陋了一些，接下来需要对博客进行一些雕琢。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>入门博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派入门]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[树莓派入门（控制LED灯）author： 刘真真 写在前面：树莓派是基于Linux的迷你主机，但功能完善，且预留了很多IO口给开发者扩展，比单片机的功能强大不少，可以将Python程序移植到树莓派上。本文简单介绍了新手如何使用树莓派和利用树莓派点亮一个LED灯。 一、板载资源+配件树莓派是迷你主机，集成在一块电路板上。其型号为Rsspberry Pi 三代B型。 电源 ：Micro USB 接口的手机充电器，输出5V2A Micro SD卡 ：充当硬盘功能，大小最好在8G以上。 显示器：HDMI接口的显示器，需要屏幕则接 键盘：树莓派内置蓝牙，USB或蓝牙的无线键盘都可以用。需要时则配。 二、电子元件1、面包板 2、一段公头一端母头的杜邦线 3、LED二极管 4、1K的电阻 三、安装系统1、下载树莓派系统 网址: https://www.raspberrypi.org/downloads/ 选择需要的系统即可。这里我们选择树莓派官方的系统，预装了桌面和部分软件，如下图箭头所指。如果有一定的开源系统使用经验，可以选择最为轻量的只有操作系统的裸机。 2、将SD卡格式化 ​ 直接在文件资源管理器中将SD卡格式化即可 3、下载将系统导入内存卡的工具etcher 安装成功后打开，首先选择下载好的系统镜像文件，然后选择树莓派内存卡，点击Flash。 注意：在此过程中如果提示不可识别文件系统或者要格式化，直接点X关闭即可。 flash完成后，将内存卡取下插入树莓派，开机即可查看新系统！ 四、SSH登录安装系统之后，选择树莓派联网方式，树莓派有网线接口和WiFi芯片，用WiFi上网更加方便。在打开新系统时，搜索局域网输入密码即可。用SSH将电脑和树莓派系统连通，首先打开树莓派的SSH功能，在命令行输入： 1sudo raspi-config 得到如下的设置 进入第五项Interfacing Options，然后选择SSH： 使能SSH即可。电脑和树莓派连接同一个路由器，在浏览器访问路由器的IP（192.168.1.1），查看树莓派的IP地址为192.168.1.101。在客户端输入树莓派的用户名 pi 和密码 123456： 1ssh pi@192.168.1.101 与树莓派建立连接。 五、远程桌面为了更加方便地操作树莓派，安装远程桌面。打开树莓派终端，输入 1sudo apt-get install xrdp 等待安装完成。 打开电脑的远程桌面 输入树莓派的IP地址，远程桌面操作，用户名pi， 密码123456，连接成功： 六、点 亮 LED树莓派提供了一组通用IO口，称为GPIO。40个引脚的定义与板上引脚资源对应如下 将树莓派和电子元器件连起来。注意二级管的正负极。正极接3.3V，负极通过电阻接地，可以看到二极管亮了。下面使用Node脚本控制LED。 首先，将接地的导线从GND针脚拔出，接到GPIO0.0即11号引脚。注意，3.3V的针脚是是有标识的为方的，其他针脚都是圆的。代码如下： 1234567891011var rpio = require('rpio')rpio.open(11, rpio.OUTPUT)function blink()&#123; rpio.write(11, rpio.HIGH); setTimeout(function ledoff()&#123; rpio.write(11, rpio.LOW); &#125;,50);&#125;setInterval(blink, 100); 用node.js稍作尝试，接下来轮到主角python出场了，Linux系统中很多功能是通过python实现的，且内嵌了python，无需安装，与python的兼容性极好，所以尝试用Python使LED闪烁。 代码如下 1234567891011121314151617#!/usr/bin/python#author:lzzimport RPi.GPIO as GPIOimport timeGPIO.setwarnings(False)GPIO.setmode(GPIO.BOARD)#BCM和BOARD两种命名模式GPIO.setup(11, GPIO.OUT)while True: GPIO.output(11, GPIO.HIGH) time.sleep(0.05) GPIO.output(11, GPIO.LOW) time.sleep(0.05)GPIO.cleanup() 程序逻辑： 1、导入GPIO的包 2、导入与时间包 3、设置GPIO针的命名方式，可用的有GPIO.BCM和GPIO.BOARD，分别代表boardcom命名系统和树莓派板子上的命名系统。 4、将引脚11设置为输出 5、控制引脚11的电平高低变换 6、清除掉之前RPi.GPIO.setup()设置的状态。退出程序前一定要调用，否则下次调用会出错。]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>入门</tag>
        <tag>LED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Hexo!]]></title>
    <url>%2F2019%2F01%2F17%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[使用hexo，是一件非常简单的事情。测试文本。]]></content>
  </entry>
</search>
