---
title: 单例模式
date: 2019年8月14日 10:05:00
categories: Java
tags: [单例模式,设计模式]
---

## 单例Singleton

确保一个类只有一个实例，并提供该实例的全局访问点。Singleton通常被用来代表那些本质上唯一的系统组件，比如**窗口管理器或者文件系统**。

使用一个**私有构造函数，一个私有静态变量以及一个公有静态函数**来实现。私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。
<!--more-->
### 最简单的单例实现：饿汉模式

```java
public class Singleton {
  //类装载的时候已经初始化
  private static final Singleton instance = new Singleton();
  //构造器私有化
  private Singleton(){ }
  //提供公有的获取方法
  public static Singleton getInstance(){
    return instance;
  }
}
```

这种实现方式虽然不是最好的实现方式，但是是最常用的单例的实现方式。因为类一开始即被装载，所以不用担心线程安全的问题。但是缺点就是如果不使用这个类，就会内存浪费的问题。

### 线程安全：双重检查模式

加锁操作只需要对实例化部分的代码进行，只有当instance没有被实例化时，才需要进行加锁。

```java
public class Singleton {
  //volatile的生命作用是内存变量共享，和禁止指令重排序
  private static volatile Single instance;
  //构造器私有化
  private Singleton(){}
  //提供公有的获取方法
  public static Singleton getInstance(){
    if(instance == null){
      synchronized (Singleton.class){
        if(instance == null){
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
}
```

为什么在锁的内部还有再加一层if判断呢，如果只有一个if语句，在instance==null的情况下，如果两个线程都进入了if语句块中，虽然在if语句块中有加锁操作，但两个线程都会执行实例化`instance= new Singleton()`这条语句，只是时间问题。那么就会进行两次实例化。破话了单例模式。因此需要两个if语句：第一个语句用来避免instance已经被实例化后的加锁操作，第二个if语句进行了加锁，只有一个线程进入，不会出现多次实例化的情况。

### 静态内部类实现

当Singleton类被加载时，静态内部类SingletonHolder没有被下载进内存。只有当调用getInstance()方法时从而触发SingletonHolder.instance时SingletonHolder才会被加载。此时初始化INSTANCE视力，并且**JVM确保INSTANCE只能被实例化一次。**

这种方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持。

```java
public class Singleton {
  private Singleton(){}
  //静态内部类不会在一开始被装载，所以没有内存消耗的问题
  //JVM在装载静态内部类是线程安全的，只有在使用内部类才会去装载，所以线程是安全的
  private static class SingletonHolder {
    private static final Singleton INSTNCE = new Singleton();
  }
  public static Singleton getInstance(){
    return SingletonHolder.INSTANCE;
  }
}
```

JVM装载内部类并不是程序启动就装载，而且装载内部类是线程安全的。所以这个单例模式真正意义上实现了懒加载与线程安全且节省了内存。

### 枚举实现

实现单例模式只需编写一个包含单个元素的枚举类型：

```java
public enum Singleton {
  INSTANCE;
  public void updateInstance(){    
  }
}
```

简洁，且无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。可以防止反射攻击，防止反序列化重新创建新的对象。

## 参考资料

[1] Effective Java 中文版

[2] 技术面试必备基础知识 

[3] [CodeSheep单例模式](http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484279&idx=1&sn=5c119c82038686c85570c4adf1511cc6&chksm=fdded5b3caa95ca5f5b3bcfb636a67fe35a48ed6449162eafc89dc1ca0d970ab4e79b179347f&mpshare=1&scene=23&srcid=08142mvZInYGTWDibuHY9qHP&sharer_sharetime=1565748070691&sharer_shareid=0a9c585f82185ac6442d5cc5cd84d6ac#rd)

